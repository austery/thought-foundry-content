---
author: AI超元域
date: '2026-02-10'
guest: ''
layout: post.njk
source: https://www.youtube.com/watch?v=iJEfIc1mrsc
speaker: AI超元域
tags:
  - token-efficiency
  - code-execution
  - ai-development-workflow
  - agentic-collaboration
  - cloud-code-hooks
title: \"Open Cloud 调用 Cloud Code 省 Token 秘籍：Hooks 与 Agent Teams 实现全自动开发\"
summary: \"本视频揭示了 Open Cloud 调用 Cloud Code 时高 token 消耗的根本原因——传统轮询机制。通过引入 Cloud Code 的 Hooks 功能与 Agent Teams 特性，实现了真正的零轮询和全自动开发流程。这种创新方法能极大节省 token 消耗，并支持后台独立运行，通过回调通知用户任务完成，显著提升了开发效率与生产力。\"
insight: ''
draft: true
series: ''
category: ai-ml
area: tech-engineering
project: []
people: []
companies_orgs:
  - OpenAI
products_models:
  - GPT-4o
media_books: []
status: evergreen
---
### Token 消耗的痛点与 Agent Teams 的潜力

最近为大家做了多期 **Open Cloud** 的视频，而且昨天我还发了一期 **Open Cloud** 的高级用法视频。但最近我发现几乎每期视频的评论区都会有留言，提到 **Open Cloud** 调用 **Cloud Code** 会非常消耗 **token**。

因为在之前的视频中，我为大家演示过用 **Open Cloud** 来调用 **Cloud Code** 进行编程开发。我们只需要为 **Open Cloud** 下达一个指令，然后让 **Open Cloud** 全程操作 **Cloud Code** 为我们实现编程开发。但是如果我们采用传统的方式，也就是常规的方式，让 **Open Cloud** 直接调用 **Cloud Code** 的话，那么 **Open Cloud** 每隔几秒就会**轮询**一次，检查一下 **Cloud Code** 的状态以及 **Cloud Code** 的输出。使用这种传统方式的话，**Open Cloud** 必须时刻盯着 **Cloud Code**，所以 **Open Cloud** 就会消耗非常多的 **token**。

因此，我在评论区发现大家抱怨 **Open Cloud** 调用 **Cloud Code** 会消耗更多的 **token**，因为大家采用的是这种常规的传统方式。所以 **Open Cloud** 需要采用不断**轮询**的方式来查询 **Cloud Code** 的状态。也就是说，**Cloud Code** 它执行的任务越久，在 **Open Cloud** 中它**轮询**的次数就越多，消耗的 **token** 也越多。

所以，我们可以完全不需要用这种传统的方式，直接让 **Open Cloud** 来调用 **Cloud Code**。因为无论是 **Open Cloud** 还是 **Cloud Code**，它们都非常非常灵活。所以越灵活就越强大，就越有利于我们去自定义一些功能，从而轻松解决用 **Open Cloud** 调用 **Cloud Code** 时产生大量的 **token** 消耗。

尤其是 **Cloud Code**，在前几天新增了 **Agent Teams** 这个新特性。这相当于在 **Cloud Code** 中，随时可以创建一个完整的开发团队。而且每个 **Agent** 都是独立的进程，所以是真正的**并行执行**。而且每个 **Agent** 之间还可以相互通信，随时共享任务列表，能自动领取任务，还能实现专职角色分工。比如说负责开发前端的 **Agent**，负责开发后端的 **Agent**，还有负责测试的 **Agent**。

所以，在 **Cloud Code** 中有了 **Agent Teams** 这个最强大的新特性，在 **Open Cloud** 中就可以更加轻松地像 **Cloud Code** 委派任务，让 **Cloud Code** 全自动完成整个开发工作流。

### Hooks 回调：实现零轮询与高效通知

想让 **Open Cloud** 更节省 **token** 的方式来调用 **Cloud Code**，其实非常简单，我们只需要用到 **Cloud Code** 的 **Hooks** 功能。在 **Open Cloud** 中可以结合 **Cloud Code** 的 **Hooks** 功能，只需要调用 **Cloud Code** 进行自主开发，并且能够实现真正的**零轮询**，而且还能非常节省 **token**。

当开发任务完成之后，我们还能在聊天软件的群组中自动接收到任务完成的通知，包括实现了什么任务，然后项目存储的路径还有耗时，还有 **Cloud Code** 的 **Agent Teams** 是否已经启用，还有具体完成的功能，还有项目的文件结构等内容。

下面我们就看一下我是如何通过 **Cloud Code** 的 **Hooks** 来实现了整个流程。下面我们先通过这个流程图，让大家更直观的感受一下，在 **Cloud Code** 中，通过 **Hooks** **回调**来实现了整个步骤是怎样的。

首先是由 **Open Cloud** 将我们要开发的任务委派给 **Cloud Code**，这个委派只执行一次，而且它是后台运行不会阻塞 **Open Cloud** 的对话窗口和它的**主 Agent**。当 **Cloud Code** 接到任务之后，它就会进行自主开发和测试。当任务完成之后，它就会触发事件。

第三步就是 **Cloud Code** 中 **Hooks** 自动触发，它会先将执行结果写入到这个文件中，然后再发送 **event** 来唤醒 **Open Cloud**。在这里采用了 **stop hook** 以及 **session end hook**，实现双重保障来保障。在聊天软件中，我们能够真正收到它的任务完成的通知。然后 **Open Cloud** 会读取这个文件中的这些结果和状态。当它读取完这些结果和状态之后，它就会回复给我们，也就是通过我们的聊天软件来回复给我们这个状态。

像这个流程的话，**Open Cloud** 只在给 **Cloud Code** 派发任务的时候调用一次 **Cloud Code**。然后这中间的流程不需要 **Open Cloud** 参与。在最后这里 **Open Cloud** 再读取一下这个执行的结果，并且将结果发送给用户。所以，在第一步 **Open Cloud** 只是给 **Cloud Code** 下发一个任务，它下发任务的过程所消耗的 **token** 几乎可以忽略不计。在最后这里它只是读取一下结果，将处理结果发送给用户，而且这个结果里的内容非常少，甚至不超过一千字。所以，在最后一个步骤它所消耗的 **token** 也几乎可以忽略不计。在 **Cloud Code** 自主完成这个任务的过程中，**Open Cloud** 不需要对 **Cloud Code** 进行**轮询**。

好，下面为大家讲解一下我是如何实现的。在 **Cloud Code** 中，通过 **stop hook** 来达到任务完成自动**回调**的效果。在刚才也提到了，我们使用了 **stop hook**，还用到了 **Cloud Code session end hook**。下面我们简单看一下为什么要用到这两个 **hooks**。

在 **Cloud Code** 中，一共有十四个 **hooks**。之所以我们选择这两个，是因为我们构建的这个工作流，在 **Cloud Code** 中它完成开发之后才会触发这个 **hooks**。所以使用 **stop hook** 作为主**回调**，可以保证 **Cloud Code** 真正完成开发时才会触发。在这里我们还用到了 **session end hook** 作为兜底**回调**，也就是假设 **stop hook** 没有触发成功，还有这个 **session end hook** 能够作为兜底。像这样的话，我们就能够真正保证 **Open Cloud** 向 **Cloud Code** 发送一条开发任务，然后 **Cloud Code** 独立运行。在 **Cloud Code** 独立运行的这个过程中，它并不会消耗 **Open Cloud** 上下文。当 **Cloud Code** 完成开发后才会触发 **hooks**，然后我们的聊天软件就会收到通知。

### 实战演示：非阻塞开发与成果交付

下面我们就可以看一下具体的代码。在这个代码中，我们先看一下这一个脚本，它的作用就是将要开发的任务写入到这一个文件中，然后再通过这个脚本来启动 **Cloud Code**。当 **Cloud Code** 完成开发后，这个 **stop hook** 就会自动触发，然后就会调用这一个脚本。我们可以点开看一下这一个脚本，就会将任务发送给 **Open Cloud**。所以这个自动**回调**流程它会读取这两个文件里的内容，并且写入到这一个文件。然后 **Open Cloud** 就会将这些信息推送到我们的聊天软件。这样的话，我们就能够实现在 **Open Cloud** 中，像 **Cloud Code** 下达开发任务，然后由 **Cloud Code** 自主完成开发。当完成开发之后，再触发这两个 **hooks**。最后我们的聊天软件就会收到推送通知。

好，下面我们可以先用一个简单的开发案例来测试一下。在**主 Agent** 这里，我们直接在对话框中输入我们的任务。我输入的是：“用 **Cloud Code** 的 **Agent Teams** 协作模式，构建一个基于物理引擎、HTML/CSS 的带材质系统的**落沙模拟游戏**。”然后我们直接发送看一下这个效果。

这里很快输出提示，它已经将这个任务派发给 **Cloud Code** 的 **Agent Teams**。这个开发模式就是调用 **Cloud Code** 的 **Agent Teams**，多智能体协作。这里还给出了这个工作路径，然后这里他提到完成后会自动通知到群里。

像这样的话，这个**主 Agent** 的线程并没有被阻塞，它还可以继续为我们执行其他的任务。比如说，我们在这个**主 Agent** 中继续输入任务，比如说让他查询新加坡今天的天气。然后我们直接点击发送，看一下最终的效果。

像我们如果采取传统的方式，在 **Open Cloud** 中来调用 **Cloud Code**，在**主 Agent** 中必须等到 **Cloud Code** 真正完成开发之后，这个**主 Agent** 才会继续执行我们的其他任务。像我们采取了现在这种方式，这个**主 Agent** 的进程并没有被阻塞。然后我们让他查询新加坡的天气，然后这里他就很快查询了一个天气。然后我们还可以继续输入其他任务，比如说讲个笑话。然后这里他就很快输出了一个笑话。

而 **Cloud Code** 在后台完全是自主运行，不需要我们去干预。然后我们只需要等待 **Cloud Code** 完成之后，将完成后的消息推送到这一个群组里就可以了。之所以设置为将完成后的消息单独推送到一个群组，是因为我们在这个**主 Agent** 中可能还在进行其他任务的操作。比如说让他讲的笑话，他在讲笑话的时候，突然多出来一条任务完成通知，这样会导致这个上下文窗口比较混乱。所以我们就将它完成后的这个消息，单独推送到一个群组里。这样的话就不会占用这个**主 Agent** 的这个聊天窗口。

在这个群组里，我们就看到了这个消息推送。我们点开群组查看一下。在这里我们就看到了这个任务推送，这里提示 **Cloud Code** 任务完成。这里是开发的这个游戏，然后这里是游戏的路径。在 **Cloud Code** 中使用的就是 **Agent Teams**。这里就是给出的项目文件。然后这里他还推送了第二条消息，这里还给出了完成时间大概六分钟。然后这里还包含一百八十四个测试是通过。然后这里就是给出的交付。然后这里还给出了这些性能。

下面我们可以输入提示词，让他将代码文件打包发给我。这样的话，我们就可以在本地打开进行测试。因为我的 **Open Cloud** 是运行在云端的。

好，这里它将为我们开发的这个项目文件发送给了我们。这里还提示解压后，在浏览器中就可以打开使用。然后我们直接点开，然后我们在浏览器中打开看一下这个效果，就是它开发的这个**落沙模拟游戏**。

我们可以先测试一下，我们选择这个沙子。好，这样点击之后，这个沙子就落在了底下。然后我们再点击这个水。好，可以看到水落在了沙子上。然后我们再给它加一把火。可以看到这个火会往天上飘。再给它加一些木头，然后再给它加一些蒸汽。可以看到这个蒸汽飘到木头上会变成雨。

像这样的话，我们就真正实现了在 **Open Cloud** 中调用 **Cloud Code** 进行开发。大家就不用担心在 **Open Cloud** 中调用 **Cloud Code** 非常浪费 **token**。**Open Cloud** 所消耗的 **token** 几乎可以忽略不计。哪怕我们不在电脑前，也可以通过手机向 **Open Cloud** 下达开发指令。当完成开发之后，我们就可以在群组中查看推送的消息。

本期视频所用到的代码和笔记，我都会放在视频下方的描述栏或者评论区。如果你在视频下方无法找到的话，也可以通过我的博客去查找本期视频所有对应的笔记。

好，本期视频就做到这里，欢迎大家点赞、关注和转发，谢谢大家观看。