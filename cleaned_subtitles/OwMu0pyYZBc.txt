Let's explore how developers can use Cloud Code to modernize a COBOL codebase. For the purposes of this demo, we'll use AWS's mainframe modernization demo repository. This is a medium-sized credit card management system with around 100 files, including COBOL programs, copybooks, and JCL scripts. Phase 1, Discovery and Documentation Our sample COBOL codebase has almost no documentation. This is, of course, common with legacy code bases where critical business logic and regulatory requirements are embedded within undocumented code. The developers who wrote the code have long since left the organization, and developers familiar with COBOL are hard to hire. We first create a specialized subagent using clodcode/agent command. This was our COBOL documentation expert and translator. Subagents can be invoked by cloud code in parallel, and they operate with their own isolated context windows. to avoid polluting the main thread. We enabled thinking mode and asked Claude Code to analyze the architecture of the codebase. Claude Code created a to-do list of all 94 files and tracked its progress to ensure no files were processed twice and nothing was missed. The documentation Claude produced went beyond simple code comments. For example, let's look at the interest calculation program CBA CT04C. It extracted the complete business workflow, how the program reads transaction category balances, looks up interest rates by account group, applies business rules for fallback rates, and updates account records. Claude did this for each file, but also created two memory files as plain text. Catalog.txt translates cryptic names like cbact04c into interest calculator batch program. Relationships.txt maps every dependency using a simple pipe delimited format. Using these indices, Claude then generated mermaid diagrams, a complete map of the daily batch processing workflow, showing how the data flows from transaction input through posting, interest calculation, and finally to customer statements. In this demo, Claude Code ran continuously for an hour to draft over 100 pages of documentation. But Claude Code is capable of running for over 30 hours autonomously. And the techniques used here scale to much, much larger code bases. Phase 2, Migration and Verification. After thoroughly documenting the Cobalt codebase, we asked Claude to migrate one of its core features to Java. We switched to planning mode to ensure Claude would think through the entire migration strategy without prematurely editing files. Claude analyzed the program formerly known as CBA-CT04C and identified complex Cobalt patterns like line break processing and multi-file coordination. Claude developed a migration plan for this feature with five phases. 1. Create the project structure. 2. Translate data models from copybooks to java classes. 3. Build the I/O layer compatible with the original file formats. 4. Convert business logic while preserving COBOL-specific behaviors. And finally, create a dual test harness, one using GNU/COBOL 3.2.0 for the original codebase, and one in Java 17. The resulting Java code went beyond a simple syntax translation. Claude created proper Java classes with appropriate design patterns, error handling, and logging. Idiomatic Java that a modern development team would actually maintain. Next was verification to ensure that the new Java code worked the same as the COBOL code it was replacing. Claude created multiple test data files and ran them against both the original COBOL and the new programs. The verification compared not just final outputs, but intermediate calculations, file writes, and data transformations. The result was perfect bit-for-bit fidelity. Every calculation, business rule, and edge case was preserved. Of course, this demo application is far smaller than your legacy COBOL code bases, but all the techniques here are scalable. Cloud Code will empower your developers to modernize code bases with confidence and efficiency that simply would have been impossible just 12 months ago.