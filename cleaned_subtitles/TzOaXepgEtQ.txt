Test Driven Development， TDD，是一种以测试驱动开发的模式 简单来说 就是拿到开发需求后 先凭空把测试写出来 因为这个时候是没有实际代码的 所以测试必然是失败的 然后你的工作就是把实际代码写出来 让测试结果的红灯一个个变绿 直到全部通过 之后再对代码进行重构、 增加新功能时 也要确保已有测试继续保持绿灯状态 作为一个程序员 你应该多多少少都听说过TDD 但你们中的大部分应该都没有做过TDD 毕竟这种做法还是有点极端的 和大家平常的开发模式区别较大 愿意冒着风险尝试的 一般情况下 都是因为 项目负责人自己就是TDD教徒 这类人相对而言不太多 所以与前两期的UML和Agile相比 TDD在计算机行业的影响力没有那么大 但同样是90年代 个人计算机热潮中 诞生的软件开发理念 TDD之于代码测试 就像UML之于系统设计 Agile之于项目管理 都是具有历史代表意义的 所以TDD绝对值得一期墓志铭 而且从它的失败中 我们还能尝试 解答一个困扰大家已久的问题： 为什么我们都不想写测试 都不想更新它、修复它 即使我们在日常工作中 最讨厌的就是别人不写、不更新、 不修复测试 测试本应该是我们的守护者 却活成了我们最讨厌的邻居 答案，就在TDD犯下的错误里 在60年代 美苏冷战进入到比拼载人航天的环节 NASA的水星计划 只有一个硬指标 就是要比苏联快 所以他们的软件开发部门 被设计成开发和测试并行的组织结构 一旦产品的功能需求文档定稿 就会被同时发送给开发组和测试组 两边同时开工 最后顶峰相见 作为美国历史上最成功的工程项目 水星计划中用到的诸多项目管理方式 也自然成为后人借鉴的模板 这其中就有一位叫做Kent Beck的青年 没错，他就是上期的男主角 eXtreme Programming, XP模式的创始人 他很喜欢借鉴古人的做法 然后再把它们推到“极限”的程度 这也是extreme这个词的来源 当他在克莱斯勒的项目组里 打造XP模式时 在测试这个工作上 他也借鉴了NASA的做法 只不过他更极端 直接把测试的位置提到了最前沿 在他的模式下 需求文档确认后 首先要做的 是用unit test 把所有可能出现的状况都测一遍 这相当于用测试代码 将需求文档翻译了一轮 那么接下来入场的开发 就不再是由需求文档来引导 他们唯一的任务 就是写下能让这些测试通过的代码 这就是测试驱动的开发，test driven development TDD的来源；即使在XP全家桶里 TDD也算是比较极限、比较极端的那个 因为大多数XP理念 只是一种指导型方案 只包括对大方向的描述 具体怎么做 还得是看程序员自己的理解 和开发团队的相互配合 但TDD是一个非常具体的方案 它基本上是在手把手教 你怎么写代码 它会深入影响每一个人的编程风格 你每次敲击键盘都要遵循它的规则 这也是为什么喜欢它的人很喜欢 讨厌它的人很讨厌 那些喜欢TDD的 通常都会非常积极地向周围的人推荐 TDD的做法 具体原因，可以参照人类宗教史 某种程度上 这也造成了TDD无处不在的假象 因为它的存在感 确实是比它的实际存在要大很多 就像在上上期里 出自于RUP管理模式的UML TDD也因为它广泛的通用性 脱离了XP 成为一个独立传播的开发模式 只不过 它的传播显然没有UML那么成功 作为一个诞生在90年代的开发模式 TDD的第一个国际级conference 是在2021年才召开的 14位演讲者通过线上会议的形式 从各个角度 分享了自己的TDD成功故事 以及为什么大家都应该用TDD 截止至本视频发布 据我所知 这也是TDD的最后一个conference RIP了属于是 在unit test层面定下代码要求 在有经验的人听起来 就像是一个坏主意 因为 这相当于让具体代码的实现细节 和测试过度耦合了 会锁死代码之后的调整空间 而作为首个应用TDD的软件项目 Kent Beck主导开发的 克莱斯勒员工薪酬管理系统 在第一个版本交付后 就因为员工过劳，无法继续 两年后就被关停了 作为XP发源地的克莱斯勒也宣布 集团内部禁止一切XP模式 不知道是不是受 到这次失败的教训影响 TDD的执行也开始从unit test层面往上走 他们不再追求最小单位的测试 而是转向更大范围的 在需求层面的测试 这也衍生出了acceptance test driven development, ATDD 将unit test替换成acceptance test 面向客户的验收测试 但不管测试的范围怎么调整 TDD有一个本质是不变的 那就是尝试在实际开发开始之前 在测试代码中想象和框定最终成果 这种透支未来的做法 听起来是不是有点既视感 因为这也是前两期墓志铭主角 UML和Agile在做的事情 不管是代码测试、系统设计 还是项目管理 正常的顺序都是应该先有需求 然后有实现 最后有结论 但TDD、UML和Agile想的都是 把后面两步反过来 先下结论 再去实现 这样是不是就能运筹帷幄 事半功倍了呢？ 这种抄捷径的想法，通通忘记 考虑了最重要的一个影响因素： 那就是在软件项目中 “需求”不是一个常量 而是一个时刻在变化、在游走的变量 不管这个需求 是来自业务方的功能需求 来自领导层的业绩压力 还是来自生产环境的安全隐患 它往往都是一个移动靶 当你的理论是基于一个假设的常量 然后在这个常量的基础上画坐标 在这个坐标上建公式 最后自证这个公式在理论上成立 那么在你发现这个常量不存在 固定的坐标也不存在的时候 你的公式就会出现越来越大的偏差 直至无法使用；牛顿他老 人家就吃过这个亏 测试本应该是我们的好朋友 前提是摆正它的位置 在TDD眼里 测试是一种代码化的需求文档 比起普通的需求文档 它过于具体 没有解读空间 让写代码的程序员 觉得自己就是个工具人 而且不管是下到unit test 还是上到acceptance test TDD提前定好了各种函数和功能接口 的做法，会让后续开发中 任何的调整都十分吃力 而且很多项目的管理团队 会把测试定义为一种KPI 将其包括在交付的指标中 所以 很多测试工作只是在纯粹地刷数据 比如经典的100%测试覆盖 他们的价值定位被扭曲 也不怪程序员嫌弃了 在我看来 测试本质上就是一种模拟 测试的价值 就是可以伪装成真正的客户 模拟使用代码和功能 模拟检验返回的结果 这个模拟的场景越真实 越接近现实的生产环境 效果自然越好 我们见过很多测试是通过了 但是在生产环境还是出bug的情况 这是因为测的场景和实际场景不一样 所以我不会在项目的设计阶段 甚至是开发初期考虑测试问题 而是在软件初见雏形、设计基本定型 大致流程跑通 可以看到结果之后 因为在这个时候 我有了一个基本能用的产品 可以想象得到 真实的使用场景是怎么样的 这个产品在哪里最薄弱 哪里交互最复杂 哪里出错最危险 都已经有一个大概的范围 就像著名程序员Atomic Energy说过 的：the moment you know what to fear is the moment you know what to test 这种理念听起来很凭感觉、 很不客观 但如果你有看完前两期墓志铭 你应该能够感受得到 软件工程就是无法完全客观的东西 所以我觉得在大方向上制定规则 然后在具体执行上 让有经验的人自主决定 才是最优解 我简单分享一下我的做法 不是为了安利 只是拿来跟TDD做一下对比 孰好孰坏 你们自己决定 我这里有一个系统 它包括了PostgreSQL、Redis 一个前端API 一个支付API 一个异步工作机（Async Worker） 这里只有前端API是面向客户的 回到二三十年前 因为技术限制 我们没有能力 在本地模拟全套的系统交互逻辑 所以要么只做一些简单的unit test 要么就用各种mocking框架 来做假惺惺的所谓模拟 但现在容器技术已经很成熟了 所以在本地一比一还原生产环境 只需要一个简单的Docker Compose配置文件 不熟悉容器技术的 可以去看【让编程再次伟大#26】的介绍 模拟环境搭建好后 我用的是一种叫做 property-based testing 的测试手法 具体做法就是 模拟真实客户可能做的操作 随机生成各种输入参数 随机调用各个前端API 然后针对系统返回的结果 当场判断 它是否符合所测功能应有的特性 比如说 某个随机生成的输入是不合要求的 那么按照这个功能的特性 就应该返回400 又比如某个API的调用顺序不对 就应该返回403之类的 这样我们就不需要手搓test case 而是随机模拟 从而把所有乱七八糟的可能性 都测一遍 因为整个测试环境都在本地 所以响应速度也很快 普通笔记本 也能在1秒内模拟100个test case 在稍微好一点的台式机上 我们还能够搞个100倍并发 顺便也把压力测试给做了 一石二鸟 这种测试我们写起来很积极 维护起来也很认真 因为我们知道 只要这些测试能通过 我们就很有信心，这个系统上线之后 不会被客户玩坏 我们晚上就能安睡 而这，就是我们的测试之道