[Speaker 1]: 本期视频继续为大家分享 open 的使用技巧，
[Speaker 1]: 还有使用经验，
[Speaker 1]: 并且还会为大家重点演示 clouopen 中 cloua 诊头的高级使用方式。
[Speaker 1]: 通过最近这段时间高强度的使用 open，
[Speaker 1]: 我最大的感受就是 clouopen clour 可以说是二零二六年最伟大的 AI 智能体，
[Speaker 1]: 而且在未来几个月还会有更多基于 open clore 二次开发的各种变体出现，
[Speaker 1]: 并且人人都会有自己的 open class，
[Speaker 1]: 甚至可以实现。
[Speaker 1]: 人类只需要给 open 下达指令，
[Speaker 1]: 一切工作都会由 open clore 自主完成。
[Speaker 1]: 因为最近几天所有的编程任务，
[Speaker 1]: 我都是直接向 open 下达指令，
[Speaker 1]: 然后由 clouopen 完成所有的开发工作。
[Speaker 1]: 所以说 clouopen class 堪称 AI agent 的终极形态。
[Speaker 1]: 好，
[Speaker 1]: 下面为大家详显示 open en oud 使用经验，
[Speaker 1]: 还有使用经验。
[Speaker 1]: 首先我们得设置一下 open cloud 模型容灾机制。
[Speaker 1]: 在这里，
[Speaker 1]: 我让 open cloud 以出当前模型容灾的配置代码，
[Speaker 1]: 还有文件路径。
[Speaker 1]: 然后这里就是 open clore 给出的模型容灾配置文件的路径。
[Speaker 1]: 然后我们可以详细看一下，
[Speaker 1]: 我这里是如何配置的这个模型容灾机制。
[Speaker 1]: 首先这里是配置的核心容灾。
[Speaker 1]: 这里我设置的这个主模型就是 anthropic 的 cloud ops 四点六模型，
[Speaker 1]: 也就是这个模型，
[Speaker 1]: 只要它的额度没有耗尽或者没有被限制。
[Speaker 1]: 那么在这个主 agent 中，
[Speaker 1]: 也就是当前对话的这个 agent 中，
[Speaker 1]: 它默认调用的模型就是我们设置了这个 anthrooppic cloud ops 四点六模型。
[Speaker 1]: 假如是使用了这个模型额度用光了，
[Speaker 1]: 或者是出现了问题，
[Speaker 1]: 或者是被限制了，
[Speaker 1]: 然后就会从这个 four bix 列表中率先选择 open in i codex 的 GPT 五点三 codex 模型。
[Speaker 1]: 假设这个模型也不能用，
[Speaker 1]: 那么就会选择谷歌 anti gravity 中的 cloud ops 四点六 thinking 模型。
[Speaker 1]: 所以做了这个模型容灾机制，
[Speaker 1]: 哪怕我们所使用的这个主模型，
[Speaker 1]: 它突然没有额度不能使用了。
[Speaker 1]: 那么在 open cloud 中，
[Speaker 1]: 它也会自动切换到 four backs 列表里的这些模型。
[Speaker 1]: 像这样的话，
[Speaker 1]: 我们就能保证哪怕主模型出了问题，
[Speaker 1]: 然后我们的 open 也能正常的来使用，
[Speaker 1]: 而不会因为我们设置的主模型出现额度限制，
[Speaker 1]: 然后整个 clouopen 都不能使用的情况。
[Speaker 1]: 所以说我设置的这个容灾机制，
[Speaker 1]: 它的执行流程就是当 clouanths topic 它的模型不能用了之后，
[Speaker 1]: 就会自动切换到 open AI 的 codex。
[Speaker 1]: 如果 open AI 的 codex 还不能用的话，
[Speaker 1]: 那就自动切换到谷歌的 anti gravity。
[Speaker 1]: 想设置这个模型，
[Speaker 1]: 容灾机制非常简单，
[Speaker 1]: 我们只需要在这个代码文件中添加好我们作为容灾机制的其他模型就可以。
[Speaker 1]: 而且在这里我还实现了多认证，
[Speaker 1]: 还有 toking 的轮换。
[Speaker 1]: 在这个配置文件中，
[Speaker 1]: 我登录了 open i 的 codex，
[Speaker 1]: 然后这个认证方式就是 o os 在这里我还登录了 anti grapic 的账号。
[Speaker 1]: 在下面这里我还登录了两个 antigravity 的账况。
[Speaker 1]: 假设说在使用 anti gravity 的账况，
[Speaker 1]: 比如说第一个 anti gravity 的账号，
[Speaker 1]: 因为额度被限制了，
[Speaker 1]: 那么就会自动切换到第二个 anti gravity 的账号。
[Speaker 1]: 像这样的话，
[Speaker 1]: 我们就就能实现 anti gravity 两个账号的轮询。
[Speaker 1]: 而且在下面这里，
[Speaker 1]: 我还为我创建了这些 agent，
[Speaker 1]: 分配了不同的模型。
[Speaker 1]: 像这个创建方式与分配方式。
[Speaker 1]: 我在上期视频也为大家演示了，
[Speaker 1]: 比如说这个主 agent，
[Speaker 1]: 它使用的模型就是 cloud ops 四点六模型。
[Speaker 1]: 然后我还创建了用于文档编写的 agent，
[Speaker 1]: 给它分配的模型是 antigravity 里的 cloud 三 mate 四点五模型。
[Speaker 1]: 所以大家想自己设置的话，
[Speaker 1]: 只需要更改这个文件，
[Speaker 1]: 然后加入你所增加的这些模型。
[Speaker 1]: 然后也可以直接让 open 为你去新增这一些容灾的这些模型。
[Speaker 1]: 下面再为大家讲解一下 clouopen 中它的记忆搜索的功能。
[Speaker 1]: 在这里我直接用起始词让它将记忆搜索的配置文件路径，
[Speaker 1]: 还有配置的这些内容将它展示出来。
[Speaker 1]: 这个文件路径就在这个位置。
[Speaker 1]: 然后我们看一下我是如何设置 clouopen 中它的记忆搜索的这个功能。
[Speaker 1]: 在这个配置文件中就可以看到它会检索 clouopen，
[Speaker 1]: 它自带的记忆系统以及检索 clousessions。
[Speaker 1]: 而且这里我开启了它的实验性功能，
[Speaker 1]: 也就是 session memory，
[Speaker 1]: 将它设为了 true。
[Speaker 1]: 在模型提供商这里我设置的是 germany，
[Speaker 1]: 在这里就是设置了 germany 的 APIK。
[Speaker 1]: 在它的模型 ID 这里，
[Speaker 1]: 我使用的就是 germany 的 m banning 零零幺这个模型。
[Speaker 1]: 在这里，
[Speaker 1]: 我之所以使用 germany m banning 零零幺这个模型，
[Speaker 1]: 而没有选择用开源的 QMD 这个项目去实现记忆检索。
[Speaker 1]: 主要是因为 QMD 它需要下载 GGUF 模型，
[Speaker 1]: 还需要实现常驻后台进程，
[Speaker 1]: 而且占用内存还有 CPU。
[Speaker 1]: 所以我选选择了使用 germany 的按 banning 模型，
[Speaker 1]: 像这样的话就能实现，
[Speaker 1]: 只需要设置一个 APIK 就可以实现混合搜索，
[Speaker 1]: 从而让 open clour 越用越聪明。
[Speaker 1]: 下面我们再看一下第三个技巧。
[Speaker 1]: 第三个技巧就是用云端的 open clall 来连接我本地的 micrel s 系统，
[Speaker 1]: 在这里并没有用到内网穿透等操作。
[Speaker 1]: 因为我使用的是云端的 open，
[Speaker 1]: 与本地的 cloumichao s 通过 node 进行配对，
[Speaker 1]: 就就是在地地 micros 上通过 SSH 反向隧道连接到云端的 open。
[Speaker 1]: 然后我们可以看一下这个架构图。
[Speaker 1]: 首先，
[Speaker 1]: 云端的 clouopen clore 它就相当于一个真正的 agent 和大脑。
[Speaker 1]: 它能通过路由工具来调用其他的这一些 node。
[Speaker 1]: 它通过 web socket server 来实现 node 指令的分发。
[Speaker 1]: 它可以通过 web socket 指令，
[Speaker 1]: 将指令通过 node 发送给 michael s 来实现调用相机，
[Speaker 1]: 实现屏幕截图、
[Speaker 1]: 实现执行命令等操作。
[Speaker 1]: 在本地 michael s 上，
[Speaker 1]: 它就是使用的 SSH 反向隧道出站连接。
[Speaker 1]: 因为它是主动出站，
[Speaker 1]: 所以不需要内网穿透，
[Speaker 1]: 也不需要端口映射等这些复杂操作。
[Speaker 1]: 而且我们只需要用命令来启动这个 node 就可以。
[Speaker 1]: 下面我们就可以看一下这个效果。
[Speaker 1]: 首先我们打开本地的终端命令行为，
[Speaker 1]: 确保它真的是通过 node 进行配对。
[Speaker 1]: 我们可以直接用这条命令，
[Speaker 1]: 直接将本地的 gateway 彻底关掉。
[Speaker 1]: 我们直接执行这条命令，
[Speaker 1]: 这里就将我本地的 gateway 彻底关掉了。
[Speaker 1]: 然后下面我们只需要在命令行中来启动 node 就行。
[Speaker 1]: 我这里将启动方式做成了快捷命令，
[Speaker 1]: 我只需要输入 AGI，
[Speaker 1]: 然后就可以启动，
[Speaker 1]: 我们直接启动。
[Speaker 1]: 好，
[Speaker 1]: 这里提示正在建立 SSH 隧道，
[Speaker 1]: 然后我们就可以回到 open clore，
[Speaker 1]: 然后给他下达一个任务，
[Speaker 1]: 让他从云端来操控我本地的 micro s 系统在输入框。
[Speaker 1]: 我们可以先输入一个指令，
[Speaker 1]: 在输入框我们本地 micico s 和你是否建立了连接。
[Speaker 1]: 然后我们看一下他输出的状态是怎样的。
[Speaker 1]: 在这里他很快输出的状态。
[Speaker 1]: 在这里就是我的 micro s 连接状态，
[Speaker 1]: 就是在在线所备备能力，
[Speaker 1]: 就是浏览览器调用等等能力。
[Speaker 1]: 在这里就是 michael s 隧道正常运行，
[Speaker 1]: 可以执行远程命令。
[Speaker 1]: 在这里我们就可以给它下达一个任务。
[Speaker 1]: 我输入的任务就是通过 microo s 上的 cloud code 调用浏览器发一篇 x post 内容就是你对 open cld 未来发展的预测。
[Speaker 1]: 然后我们直接发送看一下它能否通过云端调用我本地 mico SS 的的 cloud code，
[Speaker 1]: 再通过 cloud code 调用浏览器实现发布。
[Speaker 1]:  x post 它自动打开了我本地的 michael s 上的浏览器。
[Speaker 1]: 好，
[Speaker 1]: 可以看到它自动打开 x 并且自动输入了，
[Speaker 1]: 要发布的内容。
[Speaker 0]: 嗯，
[Speaker 0]: 不不对嗯，
[Speaker 1]: 好，
[Speaker 1]: 可以看到它这里发布成功，
[Speaker 1]: 然后这里提示发布成功，
[Speaker 1]: 这样的话我们就实现了让云端的 open。
[Speaker 1]: 通过 clounode 操控我们本地的 cloud code，
[Speaker 1]: 实现浏览器调用。
[Speaker 1]: 下面我们就可以输入提示词，
[Speaker 1]: 将云端 open 与本地 cloumichael s 通过 node 配对的步骤写成笔记。
[Speaker 1]: 这样的话，
[Speaker 1]: 大家就可以将笔记发给自己的 open，
[Speaker 1]: 让自己的 clouopen 根据笔记来实现配对。
[Speaker 1]: 在这里就是他给出的笔记，
[Speaker 1]: 像这些笔记我会放在我的博客中，
[Speaker 1]: 大家可以从我的博客去查找。
[Speaker 1]: 好，
[Speaker 1]: 下面面继续为大家讲解 open 中 clouagent 的更多使用方式。
[Speaker 1]: 在这里，
[Speaker 1]: 我创建了四个 agent，
[Speaker 1]: 并且放入了四个群组。
[Speaker 1]: 我创建了这四个 agent，
[Speaker 1]: 它们的作用就是一个开发团队的详情。
[Speaker 1]: 这四个 agent 呢就相当于四大专职的 AI 成员。
[Speaker 1]: 其中这一个 agent 呢是负责写代码的，
[Speaker 1]: 这个 agent 负责进行测试。
[Speaker 1]: 然后这一个是负责文档维护，
[Speaker 1]: 还有这一个是监控这些运行状态的。
[Speaker 1]: 我创建了这四个 agent，
[Speaker 1]: 它们的运行方式跟之前视频里为大家也演示的是不一样的。
[Speaker 1]: 目前我创建了这四个 agent 呢，
[Speaker 1]: 它完全是由主 agent 进行调度，
[Speaker 1]: 而且具备三种协作模式。
[Speaker 1]: 第一种协作模式就是线性流水线协作模式，
[Speaker 1]: 也就是由主 agent 作为调度中心。
[Speaker 1]: 它作为总指挥，
[Speaker 1]: 它会根据我们下达的任务，
[Speaker 1]: 将任务委派给下面的这四个 agent 哈。
[Speaker 1]: 最后就会根据我们下达的开发任务，
[Speaker 1]: 产出最终的成品，
[Speaker 1]: 包括代码、
[Speaker 1]: 文档等内容。
[Speaker 1]: 它支持第二种协作模式，
[Speaker 1]: 也就是依赖图并行协作模式。
[Speaker 1]: 首先可以根据任务来声明，
[Speaker 1]: 依赖关系依赖满足之后就会并行派发多个 agent 哈。
[Speaker 1]: 比如说由主 agent 进行调度，
[Speaker 1]: 可以同时调度这个用于文档维护的 agent 呢，
[Speaker 1]: 还有代码编编的 a 呢，
[Speaker 1]: 然后再并行调用这两个 agagent。
[Speaker 1]: 最后再并行调用运行测试的，
[Speaker 1]: 还有编写文档的，
[Speaker 1]: 最后给出最终的审查。
[Speaker 1]: 还有交付相加的话，
[Speaker 1]: 我们就实现了一个更加灵活的 agent 的协作工作流。
[Speaker 1]: 然后我还实现了第三种协作模式，
[Speaker 1]: 也就是多 agent 的辩论，
[Speaker 1]: 我是受 cloud code 的 agent teams 的启发来实现了像这样的话，
[Speaker 1]: 我们就可以在 open cloud 中实现让我们创建的 agent 进行多阶段的辩论。
[Speaker 1]: 首先我们只需要提出一个辩论的问题，
[Speaker 1]: 然后由主 agent 进行调度，
[Speaker 1]: 然后创建这一些控制文件，
[Speaker 1]: 然后就进入了第一轮辩论。
[Speaker 1]: 主 agent 就会派发任务给这三个 agent，
[Speaker 1]: 然后这三个 agent 的辩论结果再由主 agent 收集。
[Speaker 1]: 然后再进入第二轮的辩论，
[Speaker 1]: 再由主 agent 来生成这些任务。
[Speaker 1]: 再委派给这三个的到这一个阶段就会进行综合决策。
[Speaker 1]: 这些辩论内容就会汇总给主 agenagent，
[Speaker 1]: 进行综合决策，
[Speaker 1]: 最后给出最终的建议。
[Speaker 1]: 像这样的话，
[Speaker 1]: 我们就能真正发挥出 open 它的多 clouagent 的优势。
[Speaker 1]: 下面我们就就可以测试一下这三种协作模式中的第一种。
[Speaker 1]: 然后我们只需要在这个主 agent 中输入提示词就可以。
[Speaker 1]: 我这里输入的提示词是让它使用 team task 线性模模式。
[Speaker 1]: 开发一个 python 脚本功能，
[Speaker 1]: 就是抓取这个网站的前十条新闻，
[Speaker 1]: 然后我们直接发送看一下这个效果。
[Speaker 1]: 好，
[Speaker 1]: 这里提示这个任务已经完成。
[Speaker 1]: 当任务完成之后，
[Speaker 1]: 我们就可以看到这四个群组里，
[Speaker 1]: 这些 agent ent 分别输出了自己所完成的这些任务。
[Speaker 1]: 第一个阶段就是由编写代码的 agent 来编写代码。
[Speaker 1]: 第二个就是由测试的 agent 进行测试，
[Speaker 1]: 包括十一个测试，
[Speaker 1]: 全部通过百分之九十八覆盖率。
[Speaker 1]: 第三阶段就是文档编写的呢，
[Speaker 1]: 来编写这个 agenread me 文。
[Speaker 1]: 包含安装使用方式等。
[Speaker 1]: 最后就是由这个审查 agent 进行质量评分，
[Speaker 1]: 评分结果就是生产级的代码。
[Speaker 1]: 然后他帮我们实现了这个代码，
[Speaker 1]: 就保存在了这个位置。
[Speaker 1]: 这里还给出了运行方式。
[Speaker 1]: 像这样的话，
[Speaker 1]: 我们就实现了这个多 agent 的场景中，
[Speaker 1]: 线性流水线的这个协作模式。
[Speaker 1]: 由于时间有限，
[Speaker 1]: 剩下的这两个场景就不再为大家测试了。
[Speaker 1]: 我已经把它做成了 skill。
[Speaker 1]: 然后大家只需要将这个 skill 安装到自己的 open cloud，
[Speaker 1]: 然后就可以在 open clore 中使用这三种模式进行项目开发。
[Speaker 1]: 视频中用到的代码和笔记，
[Speaker 1]: 我都会放在视频下方的描述栏或者评论区。
[Speaker 1]: 如果你在视频下方无法找到的话，
[Speaker 1]: 也可以通过我的博客去查找本期视频所对应的笔记。
[Speaker 1]: 好，
[Speaker 1]: 本期视频就做到这里，
[Speaker 1]: 欢迎大家点赞、
[Speaker 1]: 关注和转发，
[Speaker 1]: 谢谢大家观看。