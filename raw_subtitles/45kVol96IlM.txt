How
 do
 you
 think
 about
 Python
 ecosystem


today?
 The
 Rust
 ecosystem
 and
 the
 Go


ecosystem.


>> The
 Python
 ecosystem
 is
 a
 lot
 of


infrastructure,
 a
 lot
 of
 provisioning


machines.
 Rust,
 I
 think
 if
 you
 work
 with


binary
 data,
 if
 you
 build
 a
 load


balancer,
 you
 build
 a
 database.
 Go
 in


particular,
 I
 think
 it's
 just
 a
 good


language
 for
 building
 web
 services
 and


really
 kind
 of
 only
 web
 services.


>> Speaking
 about
 AI
 agent
 coding,
 how
 are


you
 using
 them?
 I
 had
 Claude
 build
 me
 my


perfect
 control
 system
 to
 get
 my
 logs


and
 visualize
 what's
 going
 on
 in


production
 and
 I
 would
 never
 have
 done


this
 before
 just
 because
 like
 it


wouldn't
 have
 worked.


>> Why
 have
 you
 become
 so
 much
 more


positive
 about
 these
 AI
 coding
 tools?


>> So
 the
 biggest
 thing
 is
 that


>> Armen
 Roner
 is
 a
 widely
 known
 open


source
 contributor
 and
 the
 creator
 of


Flask
 a
 popular
 Python
 web
 framework.
 He


was
 also
 engineer
 number
 one
 at
 Sentry


and
 is
 now
 building
 his
 own
 startup


making
 heavy
 use
 of
 AI
 tools.
 Today
 with


Armen,
 we
 cover
 why
 AI
 coding
 tools
 are


making
 the
 choice
 of
 programming


languages
 more
 important
 and
 not
 less.


Python
 versus
 Go
 versus
 Rust
 versus


TypeScript
 and
 which
 languages
 to
 use


for
 startups
 and
 why.
 What
 Armen
 learned


about
 error
 handling
 after
 10
 years
 of


century
 and
 why
 types
 safe
 languages


like
 TypeScript
 don't
 seem
 to
 reduce


errors
 and
 many
 more.
 If
 you're


interested
 in
 understanding
 more
 about


the
 strengths
 and
 weaknesses
 of


programming
 languages,
 how
 LMS
 are


changing
 how
 startups
 are
 built
 or
 want


to
 know
 more
 about
 error
 handling,
 this


episode
 is
 for
 you.
 This
 podcast
 episode


is
 presented
 by
 Statsig,
 the
 unified


platform
 for
 flags,
 analytics,


experiments,
 and
 more.
 Check
 out
 the


show
 notes
 to
 learn
 more
 about
 them
 and


our
 other
 season
 sponsor.
 Let's
 jump
 in.


So,
 Armen,
 uh,
 welcome
 to
 the
 podcast.


>> Hi,
 happy
 to
 be
 here.


>> So,
 let's
 talk
 a
 bit
 about
 programming


languages.
 you
 you've
 been
 very
 deep
 in


into
 Python
 for
 for
 many
 many
 years
 well


over
 a
 decade
 and
 and
 now
 you've
 touched


on
 other
 languages
 but
 in
 with
 Python


how
 have
 you
 seen
 the
 Python
 itself


change
 and
 can
 you
 give
 us
 a
 for
 those


of
 us
 who
 are
 not
 as
 in-depth
 in
 Python


give
 us
 a
 bit
 more
 detail
 about
 the
 the


two
 to
 three
 migration
 drama
 which
 I


think
 if
 you
 if
 if if
 you
 work
 with


anyone
 who
 work
 with
 with
 Python
 you


you've
 heard
 the
 moaning
 u
 I
 was
 at
 Uber


when
 this
 happened
 and
 there
 was
 a
 lot


of
 lot
 of
 back
 and
 forth,
 a
 lot
 of


delaying.
 Uh
 it
 it
 seemed
 very
 rare
 for


across
 any
 languages
 to
 see
 what


happened
 from
 Python
 2
 to
 Python
 3
 which


seemed
 like
 breaking
 changes,
 lots
 of


disagreements,
 some
 people
 just
 wanting


some
 a
 lot
 of
 very
 competent
 and
 good


engineers
 wanting
 to
 stay
 on
 the
 kind
 of


two
 which
 is
 lower
 than
 three.
 So
 what


happened
 there?


>> Yeah.
 So,
 fun
 fact,
 this
 year
 was
 the


Python
 documentary


um
 which
 uh
 Grudo
 invited
 me
 to
 be
 part


of
 which
 was
 very
 nice
 and
 and
 I
 I
 had


that
 that
 documentary
 had
 a
 segment
 on


it
 on
 that
 Python
 23
 migration
 and
 that


basically
 made
 me
 go
 back
 in
 time
 just


to
 remember
 all
 of
 it.
 Um
 because
 like


in
 many
 ways
 like
 my
 memory
 was
 also


incredibly
 fuzzy
 and
 hazy
 like
 I
 also


remember
 certain
 parts
 more
 than
 others.


So
 if
 you
 really
 want
 to
 go
 into
 the


deeps
 of
 like
 Python,
 Python
 3,
 like


look
 at
 the
 uh
 the
 Python
 documentary


has
 a
 whole
 segment
 on
 it.
 But
 I
 think


like
 in
 in
 retrospective,
 I
 think
 you


can't
 do
 it
 anymore.
 It
 was
 just
 at
 this


moment
 in
 time,
 it
 didn't
 kill
 Python.


But
 I
 think
 it
 could
 have,
 right?
 it


like
 if
 people
 didn't
 put
 a
 lot
 of


energy
 in
 to
 actually
 make
 that


migration
 work,
 it
 could
 have
 been
 quite


problematic
 for
 the
 language
 because
 it


it
 if
 you
 if
 you
 go
 back
 to
 Python
 3
 and


31
 and
 32,
 there
 were
 so
 many
 missteps


in
 the
 original
 library
 designs
 and


decision
 to
 be
 made.
 And
 so
 as
 someone


who
 maybe
 hasn't
 like
 participated
 in


this
 originally,
 you
 have
 to
 consider


that
 Python
 started
 out
 with
 just
 basic


strings
 like
 C.
 Eventually,
 it
 gained
 to


be
 unicode
 strings
 as
 an
 option.
 So,
 you


did
 a
 U
 in
 front
 of
 the
 string
 and
 it


became
 a
 unicode
 string.
 And
 Python
 3's


biggest
 motivation
 of
 existence
 was
 to


be
 a
 lot
 more
 strict
 about
 strings
 and


move
 everything
 to
 unicode.
 What
 wasn't


quite
 anticipated
 is
 that
 that
 migration


was
 a
 little
 bit
 more
 uh
 nuanced
 in


practice
 than
 ant
 than than
 designed,


right?
 There
 was
 a
 very
 simplistic
 view


of
 what
 what
 Uni-ode
 looks
 in
 the
 real


world.
 and
 and
 and
 and
 that
 just
 it


didn't
 look
 like
 that.
 And
 I
 actually


think
 that
 Python's
 messy
 Python's


remigration
 also
 had
 a
 really
 positive


impact
 on
 other
 ecosystems
 like
 uh


YUbuntu
 for
 instance
 because


there
 were
 like
 two
 things
 sort
 of


happening
 simultaneously.
 Python
 3
 got
 a


little
 bit
 more
 restrict
 lenient
 to


working
 with
 non-unic
 code
 data
 but
 also


a
 bunch
 of
 the
 situations
 where
 Python


made
 it
 very
 hard
 to
 work
 with
 uni
 code


was
 actually
 all
 kinds
 of
 configuration


issues.
 So
 like
 I
 remember
 um
 not
 every


Linux
 had
 UTF8
 everywhere.


It
 was
 still
 very
 common
 for
 you
 to


connect
 to
 university
 network
 and
 not


find
 a
 UT8
 Linux
 uh
 which
 had
 all
 kinds


of
 really
 funny
 things
 on
 a
 file
 system.


Right?
 sort
 of
 these
 things
 converged
 a


little
 bit.
 So
 the
 uni
 code
 story
 got


better.
 Um
 but
 but
 you
 you
 had
 millions


of
 lines
 of
 Python
 2
 code
 that
 couldn't


work
 on
 Python
 3.
 And
 the
 initial


assumption
 was
 you
 can
 just
 you
 just


migrate
 once
 and
 then
 your
 Python
 3
 and


you're
 good.
 And
 that's
 that's
 not
 what


happened.
 We
 had
 to
 maintain
 libraries


simultaneously
 for
 Python
 2
 and
 Python
 3


for
 many
 years.
 And
 I
 for
 instance
 I
 I


remember
 meeting
 um
 at
 the
 Python


language
 summit
 in
 Florence
 where
 I


proposed
 to
 bring
 back
 the
 U
 prefix
 on


unic
 strings
 so
 you
 can
 have
 them


optionally
 because
 I
 I
 noticed
 that
 if


they
 were
 there
 I
 could
 write
 code
 that


supports
 both
 Python
 2
 and
 Python
 3.
 And


I
 still
 remember
 there
 was
 a
 huge
 push


back
 like
 why
 why
 would
 you
 even
 want
 to


maintain
 a
 library
 for
 both
 two
 and


three?
 You
 should
 just
 move
 to
 Python
 3


and
 then
 make
 everybody
 move
 like
 that.


But
 that
 just
 doesn't
 it
 doesn't
 work


like
 that.
 So
 what
 really
 made
 the


Python
 3
 migration
 ultimately
 work
 was
 a


lot
 of
 effort
 put
 in
 by
 a
 lot
 of
 people


and
 just
 a
 more
 realistic
 look
 into
 that


you
 have
 to
 it
 it
 took
 10
 years
 right
 or


more
 even.
 Um
 you
 have
 to


uh
 just
 support
 both
 versions
 in
 one


form
 or
 another.
 Um
 that
 that
 is
 what


made
 it
 work.
 But
 I
 think
 the
 Python
 3


migration
 also
 left
 a
 pretty


pretty
 important
 data
 point
 for
 future


languages
 to
 approach
 this
 better.
 And
 I


remember
 Rust
 early
 on
 specifically


pointed
 at
 the
 Python
 3
 migration
 to


demonstrate
 why
 it
 wants
 something
 like


an
 an
 addition
 system
 um
 or
 or
 I
 I


forgot
 what
 it
 was
 called
 originally
 but


but
 basically
 a a
 very
 targeted
 opting


into
 new
 features
 or
 opting
 out
 of
 all


features
 so
 that
 you
 can
 have
 code
 bases


even
 within
 the
 same
 project
 from


different
 versions.


>> Nice.
 And
 speaking
 of
 of
 the
 differences


in
 programming
 languages,
 you
 mentioned


Python
 has
 been
 was
 your
 favorite


language
 for
 a
 very
 very
 long
 time.


Later
 you
 you
 helped
 introduce
 Rust
 into


Sentry
 partially
 for
 performance
 reasons


as
 well.
 And
 now
 you're
 also
 playing


with
 Go.
 How
 would
 you
 compare
 these


languages?
 And
 uh
 like
 when
 you
 think
 of


a
 language,
 what
 what
 is
 your
 mental


model
 of
 like
 what
 is
 this
 language
 good


for,
 not
 good
 for?
 What
 would
 I
 use
 it


for?
 I
 wrote
 a
 bunch
 of
 blog
 posts
 that


are
 not
 quite
 about
 languages,
 but
 they


are
 sort
 of
 about
 my
 general
 split
 brain


in
 a
 way
 because
 I
 I
 I
 I
 have
 two


programmers
 in
 myself.
 One
 is
 I
 I
 like


building
 cool
 open
 source
 software
 that


hopefully
 thousands
 of
 people
 use
 and


put
 a
 lot
 of
 handcrafted
 efforts
 into


it.
 It's
 like
 the
 the
 Swiss
 watchmaking


of
 source
 code
 writing
 and
 there
 is
 like


I
 care
 a
 lot
 about
 the
 language.
 I
 care


about
 a
 lot
 of
 the
 API
 and
 everything.


But
 then
 when
 you
 build
 a
 company,
 when


you
 build
 a
 product,
 none
 of
 that


matters.
 Like
 the
 is
 a
 is
 a
 write
 once


run
 many
 times
 code,
 but
 not
 a
 write


once
 write
 many
 times
 against
 your
 code,


right?
 And
 so
 um
 what
 what
 makes
 Rust


amazing,
 I
 think,
 for
 for
 crafting


really
 cool
 open
 source
 code
 also
 makes


it
 a
 sub-optimal
 programming
 language


for
 a
 startup
 because


um
 that
 there's
 much
 more
 friction
 in


it,
 right?
 It's
 it's
 a
 it's
 a
 much
 more


precise
 language.
 It's
 a
 great
 lift
 up


compared
 to
 C++
 which
 is
 in
 many
 ways


what
 the
 alternative
 would
 have
 looked


at
 at
 Sentry
 for
 binary
 file
 processing


but
 it's
 it's
 a
 much
 less
 capable


language
 for
 a
 startup
 when
 it
 comes
 to


rapid
 iteration.


>> Can
 can
 you
 give
 examples
 of
 this


friction?
 What


>> compile
 times?


>> What
 like
 Rust
 compiles
 so
 incredibly


slow.
 Speaking
 about
 tool
 choices
 at


startups
 and
 scaleups,
 here's
 a
 friction


point
 that
 hits
 most
 growing
 teams.


You're
 running
 feature
 flags
 in
 one


tool,
 analytics
 in
 another,
 and
 trying


to
 debug
 user
 behavior
 in
 a
 third.
 When


you
 want
 to
 know
 if
 a
 feature
 actually


improved
 conversion
 or
 if
 something
 that


you
 shipped
 is
 causing
 a
 bug,
 you
 need


to
 manually
 shift
 together
 data
 from


these
 different
 dashboards
 and
 then
 hope


that
 the
 user
 segmentation
 matches
 up.


Most
 things
 up
 end
 up
 in
 this
 situation.


You
 should
 feature
 to
 10%
 of
 users,
 then


wait
 a
 week,
 check
 three
 different


tools,
 try
 to
 correlate
 the
 data,
 and


you're
 still
 unsure
 if
 it
 worked.
 The


problem
 is
 that
 each
 tool
 has
 its
 own


user
 identification
 and
 segmentation


logic.
 That's
 where
 static
 comes
 in.


Static
 is
 our
 presenting
 partner
 for
 the


season
 and
 they've
 solved
 the
 tool


integration
 problem
 by
 building


everything
 with
 a
 unified
 platform.


Instead
 of
 switching
 to
 point
 solutions,


you
 get
 feature
 flags,
 analytics,
 and


session
 replay
 all
 using
 the
 same
 user


assignments
 and
 event
 tracking.
 So
 you


ship
 a
 feature
 to
 10%
 of
 users
 and
 the


other
 90%
 automatically
 become
 your


control
 group
 with
 the
 same
 event


taxonomy.
 You
 can
 immediately
 see


conversion
 rate
 differences
 between


groups.
 Drill
 down
 to
 see
 where


treatment
 users
 drop
 off
 in
 your
 funnel.


Then
 watch
 session
 recording
 of
 specific


users
 who
 didn't
 convert
 to
 understand


what
 went
 wrong.
 The
 alternative
 is


running
 ETL
 jobs
 to
 sync
 user
 segments


between
 your
 feature
 flag
 service
 and


your
 analytics
 warehouse,
 hoping
 the


timestamps
 align,
 and
 then
 manually


linking
 up
 the
 data
 that
 might
 have


different
 user
 identification
 logic.


That's
 a
 lot
 of
 work.
 Static
 has
 a


generous
 free
 tier
 to
 get
 started
 and


pro
 pricricing
 for
 teams
 starts
 at
 $150


per
 month.
 To
 learn
 more
 and
 get
 a


30-day
 enterprise
 trial,
 go
 to


stats.com/pragmatic.


That's
 a
 huge
 factor.
 Um,
 you
 write
 a


lot
 more
 code
 compared
 to
 Python.
 You


spend
 a
 lot
 of
 time
 thinking
 about


types.
 I
 love
 types.
 I
 think
 they're


great.
 Um,
 but
 certain
 things
 are


incredibly
 hard
 to
 express
 with
 types.


And
 I
 don't
 even
 have
 to
 think
 about
 it


in
 in
 Python,
 right?
 working
 with


dynamic
 like
 the
 and
 I
 think
 one
 thing


to
 consider
 here
 is
 like
 the
 dynamic
 and


static
 languages
 sort
 of
 have
 aligned
 a


little
 bit
 more
 over
 the
 years.
 I


remember
 the
 dynamic
 keyword
 landing
 in


C
 was
 a
 great
 thing
 because
 it
 showed


people
 they
 can
 have
 a
 statically


compiled
 language
 with
 like
 opt-in


dynamic
 runtime
 typing
 for
 instance
 and


Typescript
 took
 that
 entire
 idea
 and


sort
 of
 applied
 it
 to
 JavaScript.
 So
 you


have
 uh
 you
 can
 have
 both
 worlds
 in
 a


way.
 Um
 but
 but
 Rust
 is
 like
 very


straightforward
 like
 there's
 just
 static


types
 and
 if
 your
 problem
 is
 a
 dynamic


type
 problem
 then
 you're
 basically
 going


to
 create
 your
 own
 dynamic
 type
 wrapper


left
 and
 right.
 It
 is
 also
 that
 the


borrow
 checker
 as
 great
 as
 it
 is
 is
 a


huge
 um
 problem
 because
 it
 doesn't
 allow


to
 express
 certain
 things
 that
 uh
 other


programmers
 expect
 there
 to
 be
 like


adjacent
 bors.
 So
 you
 you
 cannot
 have
 a


strct
 that
 bores
 into
 itself
 coming
 from


C++
 that's
 like
 why
 the
 hell
 like
 why


does
 it
 do
 that
 hey I
 here's
 my
 problem


I
 want
 to
 solve
 it
 and
 the
 compiler
 says


no
 it's
 like
 no
 you're
 wrong
 it
 should


work
 so
 so
 there
 that
 is
 like
 you
 you


can
 run
 you
 can
 program
 yourself
 in
 the


corner
 where
 it's
 like
 incredibly
 hard


to
 come
 out
 um
 so
 I
 think
 from
 that


perspective
 there
 are
 a
 lot
 of
 problems


which
 are
 not
 rust
 shaped
 there
 are a


lot
 of
 problems
 which
 are
 in
 fact
 rust


shaped
 but
 but
 a
 lot
 of
 them
 are
 not
 and


so
 one
 of
 The
 reasons
 I'm
 using
 go
 right


now
 for
 the
 new
 company
 I'm
 working
 on


is
 because
 it
 is
 a
 very
 pragmatic


language
 and
 if
 pragmatism
 is
 what


you're
 after
 then


why
 not
 and
 and
 you
 can
 expect
 it
 to


hang
 around
 and
 it's
 not
 super
 sexy
 and


and
 it
 like
 worst
 case
 even
 if
 Google


stopped
 maintaining
 it
 you
 can
 imagine


there
 will
 be
 dozens
 of
 other
 people
 who


want
 to
 keep
 it
 alive
 even
 modern
 Java


is
 actually
 an
 awesome
 language
 like
 it


has
 virtual
 threats
 and
 makes
 me
 happy


like
 I
 don't
 have
 to
 deal
 with
 promises


all
 the
 time
 um
 so
 the
 But
 it
 I
 have
 I


think
 a
 much
 more
 pragmatic
 view
 when
 it


comes
 to
 what
 a
 company
 should
 build
 its


stuff
 with
 because
 the
 focus
 is
 not
 so


much
 the
 code,
 it
 is
 the
 product
 that


you're
 building.


>> So
 you're
 you're
 now
 doing
 a
 a
 startup.


Is
 it
 is
 it
 a
 few
 people?
 Is
 is
 it
 uh


yourself?


>> So
 at
 the
 moment
 it's
 me
 and
 a


co-founder
 uh
 but
 we
 just
 started
 hiring


and
 and
 and
 also
 like
 it's
 it's
 it's
 me


and
 a
 co-founder
 a
 bunch
 of
 cloths
 and
 a


bunch
 of
 codeexes
 and
 everything.
 So


like
 the
 world
 has
 definitely
 changed
 in


the
 sense
 that
 there's
 an
 army
 of


interns
 that
 also
 now
 writes
 code
 and


that
 has
 also
 changed
 the
 way
 I'm


looking
 at
 things.
 So,
 so
 now
 it's
 it's


you
 and
 your
 co-founder
 with
 the


startup.
 You've
 got
 an
 army
 of
 clouds


and
 and
 codeexes
 and
 you're
 expecting
 to


to
 grow
 the
 team
 to
 hire
 a
 as
 as
 you've


settled
 on
 on
 the
 the
 technology
 you
 you


said
 in
 this
 case
 this
 is
 a
 lot
 of
 it


will
 will
 be
 go
 but
 what
 does
 a


programming
 language
 need
 to
 give
 you


and
 and
 for
 example
 like
 why
 was
 uh


Python
 is
 is
 very
 flexible.
 Okay,
 it's
 a


bit
 slow
 but
 but
 you
 said
 it
 was
 a
 good


choice.
 What
 what
 made
 you
 what
 would


you
 say
 like
 yeah
 go
 is
 is
 this
 good


middle
 ground
 between
 Python
 and
 and


Rust
 and
 so
 on.


>> Yeah.
 So
 right
 now
 I
 think
 if
 you
 build


any
 company
 at
 all
 you're
 going
 to
 end


up
 with
 Python
 in
 there
 if
 you
 want
 it


or
 not.


It
 will
 be
 impossible
 for
 you
 build
 a


company
 that
 doesn't
 have
 Python
 code
 in


it.
 Do
 you
 want
 to
 build
 your
 main


service
 with
 it?
 Probably
 not.
 But
 if


you
 do
 anything
 with
 ML,
 if
 you
 do


anything
 with
 data
 processing,
 Python
 is


going
 to
 be
 in
 there
 and
 and
 and
 you
 can


write
 nice
 code
 in
 Python
 too,
 right?
 So


it's
 like
 that's
 going
 to
 be
 there.
 Good


luck
 not
 having
 JavaScript
 in
 a
 company.


And
 if
 you
 have
 JavaScript,
 you
 have


TypeScript.
 So
 so
 those
 languages
 are


going
 to
 be
 there.
 Another
 question
 is


like
 how
 much
 of
 that
 code
 that
 you


write
 overall
 is
 in
 those
 languages.
 And


I
 actually
 felt
 that
 I
 don't
 want
 to


build
 backend
 services
 in
 either
 one
 of


those
 languages.
 And
 not
 even
 for


performance
 reasons,
 but
 just
 for


ecosystem,
 like
 what
 the
 ecosystems
 are


good
 at.
 Um,
 in
 my
 particular
 case
 right


now,
 a
 big
 part
 of
 what
 what
 I'm
 doing


at
 the
 company
 is
 parsing
 emails.
 And,


um,
 that's
 just
 not
 something
 JavaScript


is
 amazing
 at.
 Um,
 that's
 something


actually
 Python
 is
 quite
 good
 at,
 but
 I


think
 at
 scale
 is
 is
 it
 is
 like
 is
 is


Python
 a
 good
 choice
 here?
 And
 I
 looked


at
 it
 and
 I
 made
 the
 decision
 that
 I
 I
 I


wouldn't.
 And
 from
 the
 experience
 of
 of


of
 sort
 of
 doing
 Rust
 in
 that
 space
 at


Sentry,
 I
 felt
 that
 like
 I
 can
 totally


imagine
 that
 at
 scale
 like
 Rust
 will


make
 its
 way
 back
 in.
 But
 at
 the
 moment,


I
 don't
 think
 that
 that's
 the
 right


trade-off.
 And
 so
 when
 you
 say
 at
 scale,


this
 is
 just
 thinking
 about
 when
 you


will
 have
 to
 process
 huge
 amounts
 of
 of


data,
 lot
 lots
 of
 processes
 running
 and


so
 on.
 Are
 we're
 talking
 specifically


about
 the
 performance
 capabilities
 of


the
 language.
 I
 think
 it's
 like
 at
 scale


of
 a
 company
 and
 that
 is
 not
 necessarily


measured
 by
 how
 much
 data
 goes
 through


it.
 If
 you
 scale
 a
 company
 either
 by
 the


number
 of
 people
 working
 on
 it
 or
 the


complexity
 of
 problem
 or
 the
 the


complexity
 of
 like
 how
 much
 data
 goes


through
 it,
 you
 have
 to
 make
 tradeoffs


and
 sometimes
 that
 means
 introducing
 a


new
 language
 either
 because
 of


performance
 reasons
 or
 because
 you


integrate
 into
 some
 ecosystem
 that's


particularly
 strong
 in
 some
 certain


environment
 and
 then
 all
 of a
 sudden
 the


language
 is
 here.
 Why
 did
 Rust
 exist
 at


Century?
 Well,
 it
 didn't
 just
 exist


because
 I
 wanted
 to
 write
 Rust.
 It
 also


was
 like,
 well,
 now
 we
 have
 a
 problem


with
 performance.
 How
 are
 we
 going
 to


solve
 it?
 And
 on
 the
 one
 hand,
 it
 was


like,
 well,
 we
 could
 probably
 write
 a
 Go


service
 here,
 but
 I
 didn't
 want
 to


maintain
 another
 service.
 So,
 Rust
 was
 a


pragmatic
 choice
 of
 embedding
 it
 in


Python.
 And
 then
 later
 on
 when
 we
 did
 um


native
 symbol
 processing,
 the


alternative
 to
 Rust
 basically
 would
 have


been
 C++.
 And
 from
 my
 experience
 of


working
 with
 C++,
 we
 use
 C++
 on
 that


project
 first.
 We
 just
 had
 a
 lot
 of


crashes
 and
 I
 just
 didn't
 feel
 like
 I


want
 to
 maintain
 that
 and
 so
 then
 there


was
 no
 choice
 of
 using
 go
 because
 there


was
 no
 go
 ecosystem.
 So
 unless
 I
 would


have
 built
 everything
 from
 zero,
 it


wouldn't
 have
 worked.
 But
 Rust
 was


growing
 and
 rust
 had
 the
 same
 problem
 in


the
 compiler.
 So
 the
 rust
 ecosystem
 for


debug
 files
 was
 really
 good.
 And
 there


was
 another
 company
 also
 working
 on
 it


which
 was
 Mozilla
 at
 the
 time.
 So
 there


was
 already
 two
 shared
 interests
 in
 this


and
 and
 that
 was
 a
 really
 pragmatic


choice
 even
 though
 the
 language
 was


Rust.
 Then
 maybe
 we
 overdid
 it
 a
 little


bit
 by
 putting
 Rust
 into
 places
 where
 it


wasn't
 the
 most
 optimal
 choice
 like
 the


ingestion
 system.
 I
 I
 think
 at
 this


point
 probably
 wouldn't
 make
 that


decision
 again
 but
 it
 would
 have
 been


non-pragmatic
 at
 that
 moment
 to
 say
 like


you
 know what
 we're
 going
 to
 do
 we're


going
 to
 go
 into
 corner
 for
 like
 9


months
 and
 we're
 going
 to
 build
 this
 all


in
 this
 now.
 Um
 because
 for
 the
 the
 size


of
 the
 team
 at
 the
 time
 the
 problem
 was


too
 big
 right
 and
 so
 we
 had
 to
 reuse


something.
 So
 that's
 one
 of
 the
 reasons


I
 think
 why
 I
 can
 imagine
 that
 my


company
 is
 going
 to
 again
 end
 up
 with


adopting
 a
 language
 further
 down
 the


line
 that
 it
 kind
 of
 initially
 said
 no


to
 just
 because
 the
 situation
 makes
 it


necessary
 and
 it
 doesn't
 necessarily


have
 to
 mean
 that
 performance
 is
 the


reason.
 It
 cannot
 just
 be
 ecosystem


stability
 or
 or
 anything
 like
 that.


>> And
 speaking
 about
 ecosystem
 stability


ecosystems,
 how
 would
 you
 how
 do
 you


think
 about
 Python
 ecosystem
 today,
 the


Rust
 ecosystem
 and
 the
 Go
 ecosystem?


Python
 ecosystem
 is
 a
 lot
 of


infrastructure,
 a
 lot
 of
 like


provisioning
 machines.
 So
 um
 that's
 what


I'm
 using
 it
 for
 right
 now.
 I
 using


prumni
 with
 Python
 to
 get
 the


infrastructure
 up.
 Um
 it
 is
 really
 well


entrenched
 in
 machine
 learning.
 So


that's
 I
 have
 a
 little
 data
 pipeline


going
 on
 that
 uses
 Python.
 It
 is
 also


pretty
 good
 still
 at
 at
 at
 bringing


services,
 web
 services
 to
 some
 of
 the


things
 Python
 is
 good
 at.
 Would
 I


necessarily
 write
 then
 like
 the
 main


application
 logic
 in
 it?
 Maybe,
 right?


Because
 like
 if
 if
 if
 I'm
 doing
 a
 whole


AI
 first
 company
 and
 all
 it
 does
 is


inference.
 I'm
 just
 waiting
 on
 a
 network


layer
 anyway.
 So
 maybe
 maybe
 like


putting
 some
 things
 together
 with
 Python


is
 great.
 Um
 particularly
 also
 if
 you


start
 to
 do
 aic
 things
 where
 you
 want
 to


have
 code
 execution
 on
 demand,
 maybe


maybe
 that's
 a
 good
 choice.
 Um
 so
 I


think
 Python
 is
 a
 great
 future
 in
 it.
 I


just
 don't
 think
 it's
 the
 most
 natural


language
 to
 pick
 for
 a
 service
 where
 you


think
 like
 it's
 going
 to
 be
 a
 lot
 of


that
 like
 higher
 throughput.
 Also,
 I


think
 like
 at
 this
 point,
 Go


is
 a
 is
 a
 is
 a
 is
 an
 easier
 language
 to


write
 than
 Python
 for
 a
 bunch
 of


engineers
 because
 Python's
 increased
 in


complexity
 and
 Go
 didn't
 quite
 as
 much.


Um,
 so
 I
 I
 find
 it
 um
 to
 just
 be
 a


better
 trade-off
 for
 complexity,
 too.
 So


Rust
 I
 think
 like
 if
 you
 have
 if
 you


work
 with
 binary
 data
 if
 you
 maybe
 uh
 if


if
 you
 have
 a
 you
 build
 a
 load
 balancer


you
 build
 a
 database
 well
 maybe


databases
 now
 people
 talk
 about
 sik
 and


stuff
 but
 like
 if
 you
 if
 you
 build
 like


a
 a
 like
 a
 rust
 shaped
 problem
 which
 I


think
 is
 largely
 defined
 as
 you
 single


binary
 to
 distribute
 for
 some
 reason
 or


another
 um
 it
 you you
 can't
 deal
 with


the
 garbage
 collector
 you
 want
 very


predictable
 performance


um
 you
 really
 care
 what
 data
 layout


although
 I
 dare
 say
 also
 is
 good
 but


rest
 is
 the
 benefit
 that
 if
 if
 you
 also


then
 work
 in
 something
 that
 requires


concurrency
 and
 where
 you're
 afraid
 of


mismanaging
 memory
 um
 and
 crashes
 like


modules
 that
 they
 might
 load
 into
 some


other
 high
 security
 environment
 like
 a


browser
 seems
 like
 a
 pretty
 good
 choice


um
 working
 with
 again
 like
 dwarf
 files


like
 working
 with
 just
 data
 in
 general
 I


I
 love
 Rust
 and
 I
 think
 it's
 it's
 it's
 a


such
 a
 pragmatic
 language
 also
 for
 if


you
 extend
 Python.
 So
 if
 you
 already


have
 a
 Python
 problem
 and
 now
 you
 have
 a


performance
 problem
 or
 you
 have
 an


ecosystem
 integration
 problem
 and
 Rust


happens
 to
 fit
 good
 into
 that.
 Writing


extension
 modules
 in
 Python
 for
 Python


in
 Rust
 beats
 everything
 else
 out
 there,


right?
 It's
 a
 really
 good
 choice
 for


that.
 Go
 in
 particular,
 I
 think
 it's


just
 a
 good
 language
 for
 building
 web


services
 and
 really
 kind
 of
 only
 web


services.
 Maybe
 some
 command
 line
 tools.


One
 of
 the
 other
 reasons
 why
 Rust
 I


think
 is
 impossible
 to
 get
 rid
 of
 is
 Web


Assembly
 never
 really
 took
 off
 but
 the


use
 cases
 of
 Web
 Assembly
 are
 impossible


to
 get
 rid
 of
 at
 this
 point.
 There's
 so


many
 things
 you
 actually
 have
 to
 bring


into
 the
 browser
 and
 Rust
 can
 do
 that.
 I


tried
 it
 with
 Go.
 It's
 not
 a
 great


experience
 because
 of
 the
 garbage


collector
 and
 some
 of
 the
 complications


that
 come
 with
 running
 Go
 in
 the


browser.
 So
 you
 wouldn't
 you
 wouldn't
 do


that
 but
 with
 Rust
 you
 can,
 right?
 So


is
 it
 I
 think
 like
 you
 you
 kind
 of
 have


to
 approach
 this
 from
 a
 perspective
 of


like
 what
 am
 I
 doing
 here
 like
 what's


the
 problem
 that
 I
 have
 and
 then
 you


said
 like
 I
 want
 to
 have
 not
 more
 than


three
 four
 technologies
 in
 the
 beginning


what
 they
 use
 it


>> and
 then
 finally
 I
 guess
 the
 the
 the
 the


one
 that
 we
 didn't
 talk
 about
 which
 is


popular
 JavaScript
 typescript
 ecosystem


>> well
 in
 the
 browser
 you
 can't
 get
 rid
 of


it


um
 on
 the
 server
 I
 think
 there's
 I'm


very
 conflicted
 on
 this
 because
 I


actually
 think
 that
 it's
 it's
 it's
 It's


a
 pretty
 good
 language
 environment
 at


this
 point.
 Particularly
 like


hypothetically
 if
 if
 someone
 were
 to


make
 the
 JavaScript
 2
 like
 the
 Python
 3


of
 it
 and
 get
 rid
 of
 some
 of
 the
 naughty


stuff.
 Like
 I
 don't
 think
 anyone
 should


be
 doing
 this
 because
 I've
 seen
 the


migration.
 But
 um
 there's
 a
 lot
 of
 good


stuff
 in
 the
 language
 now.
 That's
 just


also
 some
 really
 old
 dumb
 stuff.
 Why
 am


I
 not
 building
 backend
 services
 with


with
 TypeScript
 right
 now?
 Actually,


it's
 because
 of
 the
 npm
 ecosystem.
 Like


that
 ruins
 it
 for
 me.
 I'm
 a
 I'm
 a
 low


dependency
 kind
 of
 guy.
 I
 want
 to


control
 my
 and
 I
 it
 just
 I
 feel


like
 it's
 impossible
 for
 me
 for
 me
 to


build
 productive
 in
 the
 JavaScript


ecosystem
 with
 under
 500
 dependencies


and
 that
 makes
 me
 uneasy
 on
 the
 browser.


I
 can
 live
 with
 it
 because
 like
 I
 don't


have
 much
 choice
 but
 on
 the
 server
 do
 I


really
 have
 to
 do
 it?
 Do
 I
 have
 to
 deal


with
 the
 fear
 of
 of
 of
 all
 of
 it
 and


managing
 it?
 So
 it's
 like
 that
 that


honestly
 ruins
 it
 for
 me
 more
 than


anything
 else.
 And
 so
 maybe
 maybe
 that


will
 change
 as
 that
 ecosystem
 matures
 in


other
 ways.
 But
 that
 really
 I
 think
 is


is
 the
 biggest
 reason.
 Um
 and
 it
 it


doesn't
 have
 enough
 benefits
 for
 me
 on


the
 server
 that
 I
 I
 wouldn't
 just
 say


like
 there's
 this
 idea
 that
 you
 have
 a


unified
 codebase
 and
 every
 time
 I'm


trying
 to
 make
 a
 unified
 codebase
 work,


I
 just
 realize
 that
 the
 browser
 and
 that


the
 server
 actually
 is
 sufficiently


different
 that
 it's
 very
 hard
 to


actually
 have
 that
 unified
 codebase.
 And


so
 then
 it
 just
 be
 explicit
 like
 do
 some


open
 API
 shenanigans,
 some
 code


generation
 and
 it
 actually
 feels
 much


better.


>> Yeah.
 The
 the
 biggest
 argument
 I
 I
 keep


hearing
 from
 developers
 for
 TypeScript


is
 the
 unified
 codebase
 that
 you
 can


have
 a
 React
 and
 TypeScript
 and
 then
 on


you
 use
 let's
 say
 Node
 because
 that's
 or


Express
 or
 whatever
 uh
 on
 on
 the
 back


end
 and
 now
 you
 have
 the
 same
 language


and
 people
 can
 contribute
 which
 I
 think


was
 very
 very
 compelling
 especially


before
 we
 had
 AI
 tools
 because
 now
 you


didn't
 have
 to
 learn
 a
 new
 language.
 Now


it
 it
 might
 change.
 I
 I
 said
 this


recently
 in
 a
 in
 a
 sort
 of
 talk
 I
 gave


at
 a
 meetup
 which
 is
 I
 think
 right
 now


the
 floor
 is
 raising
 the
 ceiling
 not


really
 in
 the
 sense
 that
 the


expectations
 that
 everybody
 has
 in


everything
 is
 much
 higher
 than
 it
 was


before
 but
 also
 because
 the
 expectations


are
 higher
 and
 more
 tooling
 to
 enable
 it


and
 so
 code
 generation
 for
 instance


right
 now
 is
 in
 a
 much
 better
 state
 than


it
 was
 even
 just
 two
 to
 three
 years
 ago


you
 can
 even
 buy
 offtheshelf
 open
 API
 to


SDK
 generators
 now
 right
 there
 like
 I


don't
 even
 know
 what
 the
 companies
 are


called
 Stainless
 for
 instance
 is
 one
 of


them
 which
 just
 generates
 all
 the
 APIs


for
 all
 the
 AI
 cloud
 providers
 right


now.


>> Yeah.
 For
 for
 SDKs.
 Yeah.
 They're
 one
 of


them.
 Yeah.


>> That
 was
 a
 huge
 cost
 of
 doing
 anything


at
 century
 is
 like
 how
 do
 you
 keep
 these


SDKs
 around
 is
 now
 it's
 like
 well
 I
 have


an
 open
 API
 shenanigan


I
 somehow
 magically
 on
 GitHub
 an
 SDK


appears.
 Is
 is
 it
 really
 so
 important


for
 me
 to
 have
 a
 unified
 codebase
 if
 the


code
 generation
 is
 so
 damn
 good?
 Like


all
 of a
 sudden
 it
 doesn't
 matter
 quite


as
 much
 anymore.
 Um,
 so
 I
 think
 that


there's
 definitely
 some
 value
 to
 it,
 but


you
 also
 have
 to
 imagine
 that
 if
 you


have
 the
 unified
 codebase,
 then
 the
 the


boundaries
 are
 sort
 of
 accidentally
 very


undefined.
 Particular
 with
 RSC,
 I


noticed
 this
 a
 lot
 where
 like
 it's
 very


hard
 to
 actually
 reason
 your
 head
 around


what's
 on
 the
 server,
 what's
 not.
 So


actually
 having
 this
 extra
 boundary
 for


me
 is
 almost
 like
 a
 feature.


>> Speaking
 about
 uh
 AI
 agent
 coding,
 one


thing
 that
 was
 very
 interesting
 that
 you


mentioned
 is
 there's
 two
 of
 you
 in
 the


startup
 right
 now.
 uh
 and
 you
 have
 just


a
 lot
 of
 kind
 of
 you
 know
 like
 these
 AI


interns
 running
 around
 cloth
 code
 uh


codeex
 how
 are
 are
 you
 using
 them
 what


are
 you
 seeing
 for
 them
 and
 by
 the
 way


can
 you
 also
 share
 what
 you're
 building


with
 them
 speaking
 of
 how
 Armen
 and
 his


co-founder
 use
 an
 army
 of
 AI
 interns


shows
 just
 how
 much
 software
 engineering


is
 changing
 our
 work
 as
 a
 software


engineer
 is
 no
 longer
 sequential
 doing


one
 thing
 after
 the
 other
 but
 we
 can


kick
 off
 parallel
 work
 with
 AI
 agents


this
 is
 one
 of
 the
 biggest
 changes
 in


the
 software
 industry
 in
 a
 long
 time.
 A


leading
 example
 of
 this
 change
 comes


from
 our
 season
 sponsor,
 Linear.
 Their


cursor
 integration
 lets
 you
 add
 cursor


as
 an
 agent
 to
 your
 workspace.
 This


agent
 that
 works
 alongside
 you
 and
 your


team
 to
 make
 code
 changes
 and
 answer


questions.
 Say
 you
 have
 an
 issue
 in


linear
 like
 a
 buck
 fix
 or
 a
 small


feature
 request.
 You
 just
 mention
 cursor


and
 ask
 to
 take
 a
 look
 at
 it.
 Or
 you
 can


simply
 assign
 the
 cursor
 agent
 to
 a


ticket
 and
 follow
 along
 its
 progress.


This
 delegates
 the
 issue
 and
 off
 cursor


goes.
 cursor
 then
 runs
 in
 the


background,
 writes
 the
 necessary
 code,


opens
 a
 pull
 request,
 and
 once
 you
 read


the
 changes,
 you
 can
 merge
 it.
 It
 might


not
 always
 oneshot
 tasks,
 but
 it's


pretty
 good.
 Mostly
 because
 the
 agent


had
 access
 to
 context
 that's
 already
 in


linear
 project
 plans,
 backlogs,
 issue


descriptions,
 discussions.
 It's
 so


useful.
 You
 can
 now
 delegate
 bug
 fixes,


trivial
 work,
 or
 tedious
 tasks
 to
 the


agent,
 then
 come
 back
 when
 it
 finishes.


Linear
 sort
 of
 feels
 like
 ground
 zero.


You've
 got
 to
 try
 it
 out.
 Head
 to


linear.app/prammatic.


Yeah.
 So,
 we
 scoped
 out
 the
 email
 to
 be


a
 fascinating
 space
 to
 work
 in.
 And
 so,


uh,
 you
 can
 kind
 of
 imagine
 what
 the


kind
 of
 problems
 are
 that
 you
 have
 when


you
 work
 with
 emails
 in
 one
 form
 or


another.
 And


maybe
 maybe
 a
 little
 bit
 of
 a
 of
 of of


why
 we
 went
 into
 email
 is
 because


one
 of
 the
 things
 that
 is
 very
 evident


now
 of
 the
 biggest
 shift
 in
 at least
 my


lifetime.
 what's
 capable
 of with


computers
 is
 that
 natural
 language


processing
 is
 now
 available
 at
 scale
 in


many
 languages
 um
 for
 for
 for
 a


reasonable
 amount
 of
 money
 and
 and
 that


is
 a
 good
 reason
 to
 go
 into
 email


because
 email
 is
 all
 about
 natural


language
 and
 there's
 a
 lot
 of
 good
 data


in
 it
 but
 it
 has
 been
 very
 hard
 to
 work


with
 the
 data
 in
 the
 past
 if
 you
 read
 my


blog
 you
 know
 that
 my
 opinion
 on
 AI


stuff
 for
 programming
 was
 incredibly


negative
 up
 until
 February
 March
 where


it
 slowly
 moved
 around
 and
 then
 in
 May
 I


was
 like
 holy
 nothing
 is
 going
 to


be
 the
 same
 anymore.
 And
 one
 big
 reason


why
 I'm
 actually
 so
 bullish
 on
 this
 is


because
 when
 you
 think
 into
 and
 actually


think
 it
 doesn't
 really
 work
 that
 well


for
 teams
 today.
 I
 I
 think
 maybe
 maybe


they're
 ways
 and
 I'm
 going
 to
 see
 as
 I'm


scaling
 out
 this
 company
 like
 how
 it's


going
 to
 work
 at
 scale.
 But
 one
 of
 the


reasons
 why
 I
 think
 it
 will
 actually
 be


really
 good
 is
 because
 if
 I
 if
 I
 look


over
 the
 years
 of
 all
 the
 stuff
 that
 I


wish
 I
 would
 have
 been
 able
 to
 do,
 just


didn't
 have
 the
 time
 for
 it
 and
 I
 had
 to


make
 this
 explicit
 decision
 not
 to
 do


it.
 um
 that
 I
 have
 too
 many
 cases
 of


this,
 right?
 Like
 I
 remember
 we
 we
 were


were
 reworking
 the
 grouping
 algorithm
 at


Sentry.


>> The
 group
 grooving
 algorithm,
 what
 is


that?


>> It's
 like
 making
 sure
 that
 two
 errors


which
 are
 very
 very
 similar
 are
 grouped


into
 the
 same
 group.


>> A
 grouping.
 Yeah.
 Got
 it.


>> But
 it's
 like
 it's
 it's
 a
 data
 problem


at
 scale,
 but
 it's
 also
 one
 very


specific
 data.
 And
 so
 we
 we
 spend
 like


three
 weeks
 building
 just
 a
 basic


visualizer
 for
 ourselves
 to
 figure
 out


if
 the
 new
 algorithm
 works
 better
 than


the
 old
 one.
 But


>> I
 know
 for
 a
 fact
 that
 I
 get
 this
 tool


in
 30
 minutes
 on
 the
 side
 from
 Claude.


It's
 around
 5,000
 lines
 of
 code
 and
 it


looks
 better
 and
 has
 like
 pretty
 UI
 and


everything,
 right?
 So
 the
 these
 sort
 of


there
 are
 many
 projects
 that
 didn't
 go


anywhere
 because
 the
 leg
 work
 needed
 to


build
 yourself
 this
 bespoke
 tooling
 to


even
 be
 able
 to
 pull
 this
 project
 off


like
 a
 migration
 system
 or
 something


like
 this.
 It's
 just
 too
 much,
 right?


And
 so
 that's
 I
 think
 one
 of
 the
 big


changes
 I'm
 noticing
 for
 myself
 is
 that


I
 have
 so
 many
 better
 tools
 around
 now.


Um
 that
 just
 make
 it
 much
 better
 to
 work


with.
 I
 have
 uh
 like
 I'm
 at
 the
 m
 I
 I


moved
 from
 Terapform
 to
 Palumi
 for
 one


of
 the
 services
 just
 to
 see
 how
 that


goes
 and
 and
 I
 I
 had
 Claude
 build
 me


like
 my
 perfect
 control
 system
 to
 get
 my


logs
 and
 um
 and
 visualize
 what's
 going


on
 in
 production
 and
 and
 I
 would
 never


have
 done
 this
 before
 just
 because
 like


it
 wouldn't
 have
 worked.
 Another
 big


question
 is
 like
 how
 well
 does
 it
 work


on
 a
 main
 codebase,
 right?
 My
 co-founder


is
 not
 a
 technical
 co-founder.
 Um
 but


that
 doesn't
 stop
 him
 from
 using
 clot
 or


codeex
 now.
 And
 it's
 actually
 great


because
 it
 means
 that
 even
 someone
 who


maybe
 you
 normally
 like
 in
 in
 certain


stages
 of
 a
 company
 there's
 a
 bunch
 of


stuff
 where
 you
 wish
 you
 could
 do


something
 but
 but
 it
 actually
 requires


maybe
 more
 coding
 skills
 than
 otherwise


right
 and
 so
 there's
 an
 entire
 codebase


where
 I
 basically
 don't
 look
 at
 which


actually
 validates
 a
 core
 part
 of
 the


feature
 that
 we're
 working
 on
 and
 it's


just
 vibes
 and
 it
 works.
 It's
 not


pretty,
 but
 it
 doesn't
 it's
 not


necessary
 because
 like
 the
 whole
 point


of
 it
 is
 figure
 out
 like
 is
 this
 the


experience
 that
 we
 want
 and
 and
 this
 is


great.
 And
 then
 the
 thing
 is
 like
 how


much
 of
 the
 code
 that
 I'm
 writing
 which


I'm
 feel
 like
 this
 is
 going
 to
 be
 a


foundation
 of
 what
 we're
 doing
 is
 is
 is


at
 this
 point
 aentic
 and
 like
 I
 I
 I I


guarantee
 you
 it's
 more
 than
 80%.
 And


it's
 like
 there's
 very
 there's
 very


deliberate
 code
 which
 is
 not
 written


this
 way
 or
 like
 where
 where
 like
 really


we
 put
 a
 lot
 of
 effort
 into
 it.
 But
 most


of
 the
 code
 that
 exists
 in
 this
 codebase


is
 not
 so
 important.
 It's
 a
 bunch
 of
 API


endpoints.
 It's
 a
 bunch
 of
 open
 API


specifications.
 It's
 a
 bunch
 of


run-of-the-mill
 pieces
 of
 code.


They
 should
 look
 nice.
 They
 should
 pass


all
 the
 tests.
 They
 they
 should
 follow


exactly
 the
 architecture
 that
 they
 want.


But
 if
 you
 were
 to
 compress
 them
 down


and
 say
 like
 what's
 the
 actual


information
 contained
 within
 them
 is


very
 little
 right
 and
 so
 with
 the
 right


approach
 you're
 actually
 very
 productive


with
 this.
 what
 made
 you
 so
 negative
 or


or
 like
 just
 like
 pretty
 negative
 up
 to


around
 February
 or
 so
 the
 things
 that


you
 were
 just
 really
 skeptical
 about
 and


then
 why
 have
 you
 become
 so
 much
 more


positive
 about
 like
 these
 AI
 coding


tools
 or
 agentic
 coding
 right


>> the
 biggest
 thing
 is
 that
 it
 it
 actually


now
 starts
 doing
 work
 that
 I
 hated
 doing


but
 I
 know
 I
 had
 to
 do
 so
 that
 that
 is
 a


like
 as
 an
 example
 yesterday
 I
 I
 really


had
 to
 figure
 out
 why
 one
 of
 like
 the


endpoints
 that
 I
 have
 work
 running
 there


in
 production


didn't
 work
 quite
 as
 it
 should
 and
 it


was
 it
 was
 not
 a
 problem
 of
 the
 error
 in


the
 code
 it
 was
 a
 problem
 of
 AWS


permissioning
 and
 like


>> there
 was
 like
 there
 was
 a
 chain
 of


three
 things
 that
 I
 did
 wrong


>> that
 all
 resulted
 in
 it
 couldn't
 do
 what


it
 was
 supposed
 to
 be
 doing
 right
 like


first
 there
 was
 an
 IM
 permissioning


error
 and
 then
 there
 was
 a
 a


whitelisting
 error
 on
 a
 different
 system


and
 then
 the
 final
 up
 was
 um
 I


forgot
 what
 it
 was.
 I
 think
 but
 but
 the


final
 up
 was
 also
 something
 with


maybe
 that
 was
 actually
 logic
 bug
 but


the
 point
 is
 it
 was
 one
 error
 and
 one


error
 and
 another
 error
 and
 you
 couldn't


see
 them
 all
 at
 once.


>> No.


>> And
 I
 was
 also
 busy
 doing
 something
 else


and
 I
 was
 looking
 like
 I
 know
 I
 need
 to


debug
 this.
 Um,
 but
 it's
 if
 I
 if
 I'm


going
 to
 do
 this
 now,
 it's
 going
 to
 take


me
 at least
 two
 hours.
 But
 it
 didn't


matter
 because
 because
 Claude
 was
 doing


a
 lot
 of
 it.
 Like
 I
 still
 had
 to
 copy


paste
 a
 bunch
 of
 things
 from
 the
 logs,


but
 it
 it
 knows
 so
 much
 because
 it
 has


world
 knowledge
 access.
 It
 can
 combine
 a


bunch
 of
 things
 together.
 And
 I
 and
 I
 I


could
 make
 progress
 on
 the
 thing
 I
 was


doing
 while
 it
 was
 also
 fixing
 and


debugging
 this
 production
 issue.


And
 and
 that
 is
 that
 is
 a
 there's
 a


significant
 improvement.
 The
 same
 thing


with
 um
 one
 of the
 things
 I
 hated
 the


most
 was
 creating
 repro
 cases
 but
 I
 know


that
 every
 time
 I
 got
 a
 good
 repro
 case


my
 my
 I
 enjoyed
 it
 so
 much
 more
 right


and
 now
 I
 can
 say
 claude
 make
 me
 the


repro
 case
 for
 this
 this
 is
 roughly
 what


it
 looks
 like
 let's
 not
 try
 to
 fix
 it
 I


figure
 I
 was
 like
 how
 do
 we
 get
 this
 one


function
 that
 can
 keep
 calling
 in
 a
 loop


that
 is
 what
 we're
 trying
 to
 figure
 out


here
 right
 so
 I
 was
 not
 able
 to
 get
 that


experience
 out
 of
 cursor
 even
 with
 the


aentic
 mode


prior
 compared
 to
 to
 to
 to
 May,
 April.


But
 that
 was
 really
 what


changed
 my
 opinion
 on
 it.
 And
 and
 then


as
 I
 started
 going
 deeper
 and
 deeper


into,
 okay,
 now
 that
 I
 know
 that
 I
 can


do
 this
 and
 I
 can
 do
 this
 and
 I
 can
 do


this,
 I
 also
 got
 incredibly
 adventurous


in
 in in
 giving
 it
 more
 things
 to
 do
 and


and
 now
 I
 can
 and
 I
 have
 a
 new
 sense
 of


where
 it
 could
 go


just
 by
 giving
 it
 the
 things
 I
 don't


want
 to
 do,
 but
 staying
 in
 control
 of


the
 things
 I
 do
 want
 to
 do.
 Um
 and
 and


that
 was
 that
 was
 the
 big
 shift
 for
 me


was
 was
 recognizing
 that
 it
 can
 do
 that


in
 a
 way.


>> And
 so
 far
 what
 are
 you
 seeing
 in
 what


these
 agentic
 tools
 change
 about


software
 engineering
 and
 what
 are
 the


things
 that
 don't
 change
 especially
 you


know
 you
 you've
 been
 writing
 code
 for


like
 what
 20
 years
 or
 so.
 So,
 so
 system


architecture
 and
 like
 overall
 complexity


and
 and
 like
 how
 you
 build
 things
 in
 a


way
 that
 something
 stays
 maintainable
 as


it
 scales
 into
 a
 larger
 and
 larger


company.


There's
 a
 lot
 of
 experience
 in
 it
 and
 I


also
 didn't
 have
 all
 of
 that
 experience


at
 any
 point
 in
 time.
 So
 I
 feel
 like
 I


this
 is
 one
 of
 the
 things
 where
 I
 really


like
 as
 time
 went
 on
 I
 learn
 a
 lot
 more


which
 gives
 me
 a
 benefit
 over
 my
 prior


self
 that
 didn't
 have
 that
 that
 is
 going


to
 continue
 to
 be
 true.
 Now
 there's
 a


there's
 an
 argument
 to
 be
 made
 that


maybe
 cloth
 is
 is
 like
 systems
 like
 this


will
 will
 help
 you
 and
 maybe
 can
 even


bootstrap
 these
 sort
 of
 things
 around


it.
 If
 you
 fully
 delegate
 everything


that
 you're
 doing
 to
 a
 machine,
 then
 the


person
 that
 doesn't
 do
 that
 has
 an
 edge


on
 you,


right?
 Because
 like
 there's
 going
 to
 be


some
 innovation
 that
 is
 not
 in
 these


things
 yet,
 right?
 So
 like
 right
 now


what
 these
 systems
 spit
 out
 is
 sort
 of


our
 best
 understanding
 of
 how
 stuff


worked
 up
 to
 this
 point,


>> right?
 And
 so
 having
 something
 that


maybe
 at
 scale
 is
 not
 in
 these
 corpuses


yet
 is
 where
 some
 of
 the
 edge
 comes


from.
 It
 also
 creates
 a
 better
 culture


in
 a
 company
 if
 you're
 not
 completely


delegating
 everything
 to
 a
 machine,


right?
 It's
 like
 because
 like
 what


what's
 the
 point
 if
 it's
 just
 a
 bunch
 of


like
 this
 like
 this
 is
 one
 of the
 reason


why
 I
 want
 to
 hire
 more
 people
 now.
 It's


just
 because
 plot
 is
 not
 a
 human
 and


it's
 just


>> there's
 a
 there's
 an
 energy
 to
 to
 a


well-running
 company
 and
 to
 to to


motivated
 people
 that
 just
 a
 computer


can't
 replace.
 So
 I
 think
 that
 is
 that


is
 a
 big
 part
 that
 that
 sticks
 with
 you


as
 an
 engineer
 is
 like
 understanding
 how


to
 create
 the
 systems.
 Understanding


when
 the
 code
 that
 it
 produces
 is
 is


more
 right
 versus
 more
 wrong.
 Um
 so
 I


don't
 think
 much
 of
 this
 has
 changed.
 I


feel
 the
 same
 programming
 with
 claude


even
 if
 I
 physically
 write
 less
 code.


It's
 just
 that
 I
 I
 don't
 know
 the
 the


the
 physical
 act
 of
 punching
 in
 the


keyboard
 is
 is
 not
 quite
 the
 same


anymore.


>> What
 is
 different
 though?


>> What
 has
 changed
 with
 it?
 I
 think
 the


cost
 of
 of
 building
 your
 custom
 tools


went
 down.
 Um
 the
 the
 ability
 to
 to
 make


better
 decisions
 now
 for
 me
 is
 heavily


improved.


In
 parts
 it
 is
 because
 I
 I
 it
 it
 Googles


very
 well.
 Like
 it
 searches
 the
 internet


very
 well,
 right?
 It's
 like
 if
 if
 I
 now


have
 a
 problem
 of
 a
 of
 a
 of
 a
 type
 that


I
 didn't
 have
 before,
 it
 can
 teach
 me


this
 problem.
 This
 is
 one
 of the
 things


I
 use
 a
 lot
 with
 is
 like
 I
 don't


actually
 want
 to
 get
 the
 answer.
 I
 just


wanna
 I
 also
 want
 the
 answer
 but
 I
 also


want
 to
 understand
 like
 why
 that's
 the


answer
 and
 it
 can
 do
 that
 and
 it
 can
 it


can
 put
 it
 into
 the
 perspective
 of
 it.


I'm
 not
 very
 good
 with
 a
 lot
 of
 very


complex
 math
 and
 I
 found
 that
 every
 once


in
 a
 while
 I
 need
 to
 do
 that
 and
 having


chip
 dumb
 it
 down
 for
 me
 helps
 me
 a
 lot


right
 it's
 like
 it
 it
 it
 there's


seemingly
 c
 if
 if
 a
 problem
 is
 presented


in
 a
 certain
 way
 it
 works
 very
 well
 for


me
 if
 the
 problem
 is
 presented
 in
 a


different
 way
 particularly
 a
 very


abstract
 p
 way
 in
 which
 you
 have
 it
 like


in
 many
 papers
 I
 do
 very
 I'm
 not
 nearly


as
 good
 as
 I
 should
 be
 I
 think
 for
 for


what
 I'm
 trying
 to
 do.
 But
 but
 ChD
 helps


me
 grasp
 it
 quicker,
 right?
 Um
 so
 I


think
 that's
 a
 huge
 change.
 The
 the


other
 thing
 that
 that
 definitely
 has


changed
 and
 I
 and
 I
 even
 wrote
 about


this
 recently
 is
 that
 it
 brings
 a
 whole


bunch
 of
 people
 into
 programming
 that


didn't
 do
 this
 before.


>> Yeah.


>> Like
 I
 wrote
 about
 this
 before,
 but
 like


I
 had
 a
 4hour
 conversation
 with
 a
 air


traffic
 controller
 on
 a
 train
 who
 as
 a


like
 talks
 about
 how
 he
 used
 CH
 GPD
 and


like
 how
 like
 he
 he
 can
 even
 do
 some


programming
 with
 it,
 right?
 It's
 like


that's
 a
 programmer
 now.


>> Yeah.


>> Like
 he
 has
 a
 very
 specific
 problem.
 He


wouldn't
 have
 programmed
 before,
 but


because
 there's
 codecs
 in
 the
 CHPD


subscription,
 he's
 able
 to
 solve
 some


problems
 that
 he
 wasn't
 able
 to
 solve


before.
 And


that
 is
 a
 huge
 unlock,
 right?
 We're


going
 to
 have
 many
 more
 programmers
 just


because
 as
 a
 byproduct
 of
 asking
 a


question,
 Chpd
 is
 programming
 and
 and
 a


human
 is
 going
 to
 keep
 running
 that
 code


and
 maybe
 it
 wants
 to
 do
 some
 changes
 to


it.
 One
 of
 the
 side
 effects
 of
 of
 flask


being
 so
 popular
 is
 that
 it
 has
 been
 in


university
 courses.
 It
 has
 been
 in


onboarding
 in
 for
 for
 for
 new


programmers
 in
 like
 uh
 boot
 camps
 and


things
 like
 that.
 So
 I've
 been
 exposed


in
 one
 way
 or
 another
 through
 what
 how


long
 it
 takes
 for
 someone
 to
 learn


programming.
 That's
 not
 a
 thing
 that
 you


do
 in
 a
 day.
 So
 for
 you
 to
 be
 a


productive
 programmer
 that's
 capable
 of


spitting
 out
 the
 program,
 that's
 a


couple
 of
 months
 of
 work.
 And
 now


someone
 can
 press
 a
 button
 and
 get


something
 and
 and
 then
 maybe
 they
 enjoy


programming
 for
 that,
 right?
 Like
 maybe


there's
 like
 well
 now
 now
 I
 see
 the


effect
 of
 having
 produced
 something
 like


maybe
 you
 didn't
 do
 all
 the
 things
 but


like
 but
 it's
 still
 the
 same


gratification
 you
 get
 from
 it.
 And
 then


maybe
 that's
 a
 way
 for
 you
 to
 for
 people


that
 wouldn't
 have
 gone
 into
 programming


to
 actually
 go
 into
 programming
 because


the
 the
 the
 onboarding
 has
 been
 so
 much


easier.
 We
 talked
 a
 lot
 about


programming
 languages
 and
 you
 have
 very


specific
 you
 know
 you
 have
 your
 opinions


on
 them
 but
 with
 AI
 and
 clock
 codeex
 and


all
 these
 more
 and
 more
 capable
 agents


being
 here
 how
 important
 how
 do
 you


think
 the
 importance
 of
 programming


languages
 will
 change
 do
 you
 think
 it'll


be
 limited
 to
 a
 few
 people
 or
 or
 just


fewer
 and
 fewer
 people
 like
 yourself
 and


others
 who
 actually
 have
 spent
 a
 lot
 of


time
 understanding
 the
 pros
 and
 cons
 of


programming
 languages
 thinking
 well


beyond
 because
 it
 sounds
 like
 you
 know


you
 can
 just
 tell
 AI
 to
 like
 solve
 it
 in


whatever
 give
 it
 an
 existing
 codebase
 it


it'll
 just
 do
 it
 right
 so
 there
 is
 an


argument
 to
 be
 made
 that
 programming


languages
 might
 not
 be
 that
 important


anymore
 what
 is
 your
 take


>> well
 I
 think
 I
 I
 will
 be
 consistent
 with


the
 prior
 thing
 that
 I
 said
 which
 is
 I


think
 I
 have
 a
 lot
 of
 respect
 for


programming
 languages
 because
 of
 the


trade-offs
 that
 are
 in
 there
 and
 with
 AI


now
 I
 think
 you
 might
 have
 to
 start


looking
 into
 different
 kind
 of


trade-offs
 the
 reason
 another
 reason
 why


I
 end
 up
 with
 goal
 in
 in
 in
 in
 my


startup
 is
 because
 I
 just
 noticed
 how


good
 go
 code
 scales
 for
 AI
 because
 the


abstractions
 are
 very
 thin.
 It


understands
 the
 code
 better.
 So
 clearly


there's
 some
 there's
 there's
 a
 I
 did
 I


did
 the
 measurement,
 right?
 It's
 like
 I


I
 made
 it
 write
 a
 certain
 type
 of


program
 in
 different
 languages
 10
 times


and
 see
 like
 how
 often
 did
 it
 pass
 and
 I


just
 noticed
 that
 it
 did
 so
 much
 better


on
 Go
 than
 it
 did
 on
 Python.
 Um
 and
 much


better
 than
 at
 Rust.
 Clearly
 languages


matter
 because
 the
 quality
 of
 what
 the


agent
 is
 going
 to
 do
 will
 matter.
 And


then
 is
 is
 any
 of
 the
 language
 they
 have


right
 now
 is
 that
 the
 perfect
 language


for
 both
 a
 human
 and
 a
 computer
 combined


work
 environment.
 I
 don't
 know
 maybe


maybe
 found
 the
 pinnacle
 of
 programming


languages
 but
 maybe
 that's
 also
 exactly


the
 moment
 in
 time
 where
 someone
 will


come
 and
 say
 like
 hey
 I
 actually
 have
 a


brilliant
 idea
 of
 what
 the
 better


trade-off
 is
 here
 because
 the
 cost
 of


doing
 this
 kind
 of
 stuff
 is
 going
 down


with
 AI
 but
 the
 cost
 of
 this
 and
 this


stuff
 is
 going
 up
 because
 of
 AI.
 So
 let


me
 rebalance
 this
 in
 a
 different
 way.


Um,
 so
 I
 actually
 I
 think
 that
 I
 think


that
 programming
 language
 will
 continue


to
 matter
 a
 lot
 particularly
 the


trade-offs
 that
 the
 programming
 language


implies
 on
 the
 runtime
 environment


matters
 a
 lot
 more.
 So
 I
 don't
 think


that's
 going
 to
 change.
 I
 think
 it's


just
 going
 to
 everything
 accelerates.


Everything
 is
 going
 so
 much
 quicker


right
 now
 or
 it
 feels
 to
 go
 so
 much


quicker
 because
 the
 the
 fundamentals
 are


shifting
 around
 and
 and
 this
 is
 not
 just


with
 now
 everybody
 wants
 to
 build
 all


the
 new
 things.
 It's
 also
 like
 you
 feel


like
 if
 you
 if
 you're
 not
 working
 all


the
 time
 now,
 you're
 missing
 out
 on
 some


of
 the
 changes.
 And
 I
 I
 don't
 think


that's
 just
 on
 the
 product
 side.
 I
 think


it's
 on
 the
 tech
 side,
 too.
 I'm
 pretty


sure
 a
 bunch
 of
 people
 who
 are
 feeling


like
 I
 want
 to
 be
 the
 first
 person
 to


build
 the
 programming
 language
 that


works
 really
 well
 for
 agents
 and
 humans


and
 and
 and
 but
 it's
 not
 just
 one


person,
 probably
 a
 lot
 of
 them
 who
 are


who
 are
 looking
 into
 this
 at
 the
 moment.


Um
 it
 it
 just
 feels
 so
 like
 there
 is
 in


fact
 a
 moment
 right
 now
 to
 build
 the


perfect
 language
 uh
 or
 a
 better
 language


that
 works
 in
 that
 environment
 because


we
 are
 probably
 not
 going
 to
 get
 rid
 of


a
 chant
 decoding
 and
 what
 is
 the


likelihood
 that
 all
 of
 the
 languages


that
 we
 have
 right
 now
 are
 are
 the
 best


ones
 probably
 not
 that
 high
 right
 so
 it


will
 be
 the
 same
 and
 different
 in
 in


many
 ways
 um
 and
 and
 one
 thing
 not
 to
 be


underestimated
 is
 that
 the
 likelihood


that
 computers
 are
 just
 going
 to
 program


and
 No
 human
 is
 going
 to
 be
 in
 a
 loop.
 I


don't
 think
 it's
 very
 high.
 I
 think
 the


human
 will
 stay
 in
 the
 loop
 longer
 than


we
 want
 and
 in
 many
 more
 cases
 than
 we


want.
 And
 so
 you
 you
 cannot
 go
 down
 to


say
 like
 well
 the
 optimal
 output
 is


write
 bunch
 of
 assembly
 code
 because


then
 nobody
 can
 review
 this
 anymore,


right?
 And
 so
 if
 anything
 the
 trade-off


will
 have
 to
 be
 like
 maybe
 higher
 level


so
 that
 reviewing
 gets
 easier.
 Also


don't
 forget
 that
 the
 thing
 with


assembly
 right
 like
 one
 of
 the
 reasons


we
 have
 higher
 language
 languages
 is


assembly
 needs
 to
 be
 different
 for
 every


architecture
 type
 or
 every
 CPU
 type


which
 uh
 which
 is
 why
 you
 know
 like
 Java


was
 so
 popular
 in
 the
 early
 90s
 it
 ran


on
 on
 both
 Macs


>> but
 if
 I
 can
 just
 have
 the
 AI
 ported
 to


my
 other
 operating
 system
 they
 could


make
 the
 argument
 that
 maybe
 that
 is
 not


needed
 anymore
 I
 for
 I
 don't
 think


that's
 the
 opinion
 that
 I
 hold


>> but
 it
 changes
 the
 cost
 of
 of
 some
 those


things,
 right?


>> Yeah.
 But
 you
 mentioned
 an
 interesting


thing,
 which
 is
 how
 everyone
 seems
 to


just
 be
 working
 all
 the
 time,
 which
 is


this
 interesting
 contraction,
 how
 AI
 or


these
 agents
 you
 can
 kick
 off
 and
 and


you
 could
 you
 could
 in
 theory
 go
 to


sleep
 and
 and
 have
 it
 just
 run
 in
 loops


for
 you
 and
 so
 you
 could
 work
 less.
 But


in
 fact,
 we're
 seeing
 working
 more
 and


you
 and
 we
 now
 have
 this
 this
 thing


which
 is
 very
 amusing
 to
 observe
 that
 AI


startups
 in
 particular
 inc
 are


increasing
 demanding
 or
 advertising
 this


996
 from
 9:00
 a.m.
 to
 9:00
 p.m.
 6
 days
 a


week
 especially
 in
 in
 a
 SF.
 They're


putting
 it
 in
 the
 job
 adverse.
 They're


they're
 posting
 it
 kind
 of
 proudly


online
 that
 in
 the
 office
 at
 midnight
 or


after
 midnight
 people
 are
 still
 there


and
 working
 hard.
 Uh
 you
 you
 you
 share


some
 thoughts
 on
 this
 as
 well
 on
 on
 your


blog.
 It
 caused
 quite
 a
 bit
 of
 stir.
 But


what
 is
 your
 take
 on
 on
 this?
 Because


you
 did
 say,
 you
 know,
 like
 there
 is
 a


lot
 of
 energy
 right
 now.
 There's
 a


feeling
 of
 like
 not
 wanting
 to
 miss
 out.


Clearly
 that's
 why
 why
 these
 people
 are


doing
 it.


>> Yeah.
 So
 handful
 of
 thoughts,
 one
 of


which
 is
 I
 actually
 have
 to
 credit
 Peter


Steinberger
 quite
 a
 lot
 of
 uh
 pushing
 me


into
 a
 decoding
 because
 he
 uh
 he
 worked


at
 a
 company
 called
 P
 PSPDF
 kit
 which
 he


sold
 and
 then
 I
 I
 don't
 want
 to
 tell
 his


story
 but
 a
 long
 story
 short
 at
 one


point
 he
 was
 kind
 of
 stopped
 programming


and
 then
 he
 fell
 in
 and
 said
 like
 hey
 I


found
 this
 this
 computer
 which
 programs


for
 me
 and
 he
 he
 said
 like
 he
 doesn't


sleep
 anymore.
 more.
 He's
 like,
 I'm
 I'm


so
 addicted
 to
 it.
 You
 should
 try
 this


in
 a
 way.
 Like
 he
 didn't
 quite
 say
 it


like
 this,
 but
 like
 I'm
 I'm
 skeptical,


right?


>> But
 the
 computer
 that
 does
 your
 work,


you
 cannot
 sleep
 because
 of
 this.
 That's


kind
 of
 so
 amusing.


>> Yeah.
 It's
 like
 I
 I
 realized
 like
 it


does
 something
 with
 your
 brain.
 If
 you


if
 you
 do
 this
 a
 trendy
 coding
 thing


because
 like
 in
 the
 beginning,
 I
 felt


like
 any
 minute
 I'm
 not
 having
 it


running
 and
 doing
 something,
 I'm
 just


wasting
 time
 right
 now.
 It's
 like
 it
 was


a
 huge
 part
 about
 this
 like
 it's
 almost


like
 a
 drug,
 right?
 it
 it
 it
 has
 this


instant
 gratification
 of
 something


happened
 and
 and
 you
 can
 kick
 it
 off


again
 and
 kick
 it
 off
 again.
 It's
 like


this
 it
 is
 a
 slot
 machine,
 right?
 And
 so


I
 think
 I
 attribute
 some
 of
 it
 to
 that


and
 it
 took
 me
 a
 while
 actually
 to
 to


come
 out
 of
 this
 like
 way
 of
 thinking


because
 it's
 not
 very
 sustainable.
 Like


there
 were
 a
 bunch
 of
 nights
 where
 I


just
 I
 I
 I
 did
 through
 the
 night
 with


with
 coding
 not
 because
 I
 felt
 like
 I'm


incredibly
 productive
 on
 something
 using


from
 a
 startup.
 It
 was
 just
 like
 just


like
 this
 is
 blowing
 my
 mind.
 I
 just
 I


just
 one
 more
 just
 one
 more
 prompt
 one


more
 prompt.
 Um
 so
 I
 think
 like
 to
 some


degree
 because
 if
 you're
 so
 AI
 close


that
 probably
 also
 contributes.
 The


other
 one
 is
 I
 think
 everybody
 sees
 the


change
 and
 wants
 to
 do
 as
 much
 as


possible.
 I
 think
 the
 tricky
 bit
 with


the
 9
 and6
 thing
 is
 that
 9
 and
 six


defines
 a
 very
 very
 specific
 kind
 of


work
 regimen
 which
 is
 you
 work
 12
 hours


a
 day
 and
 you
 basically
 don't
 have
 a


weekend.
 No.
 Um,
 I
 never
 did
 something


like
 that
 even
 though
 I
 probably
 worked


sometimes
 80our
 weeks.
 And
 the
 reason


for
 this
 is
 that
 I
 know
 that
 I
 cannot
 be


productive
 all
 the
 time.
 If
 I
 if
 I
 work


late
 at
 night,
 I
 will
 in
 the


morning.
 I
 have
 three
 kids.
 I
 have
 a


wife.
 I
 I
 family
 is
 very
 important
 for


me.
 It's
 the
 most
 important
 thing.
 So,
 I


will
 always
 arrange
 my
 work
 around
 that.


You
 can
 work
 of
 intensity,
 but
 you
 can


still
 um
 like
 do
 it
 in
 a
 way
 that
 is
 not


crazy
 hours
 at
 crazy
 times
 where
 it's


just
 like
 you're
 you're
 optimizing
 to


the
 optimal
 output
 that
 you
 can
 produce


somehow.
 And
 I
 also
 want
 to
 say
 there's


a
 huge
 difference
 between
 if
 you
 are
 the


founder
 or
 if
 you're
 very
 very
 early


engineer
 with
 a
 really
 good
 compensation


system
 where
 equity
 means
 something
 to


you
 from
 most
 of
 the
 people
 uh
 who
 join


a
 company
 later
 on
 or
 where
 the
 company


has
 no
 realistic
 path
 of
 their
 equity


being
 worth
 something.
 There's
 there's


absolutely
 no
 point
 in
 putting
 a
 ton
 of


effort
 into
 something
 where
 only
 one


person
 benefits
 from.
 And
 there's


there's
 just
 there's
 a
 lot
 of
 like


subtlety
 to
 all
 of
 this.
 And
 what
 annoys


me
 with
 the
 9
 and
 six
 point
 in


particular
 is
 that
 they
 picked
 that
 word


which
 if
 if
 you
 go
 back
 to
 why
 that


naming
 even
 exists
 is
 because
 of


basically
 there's
 no
 subtlety
 to
 it.


It's
 like
 you
 work
 12
 hours
 a
 day,
 six


six
 days
 a
 week,
 and
 you
 give
 up
 what


what's
 what
 what
 is
 otherwise
 in
 your


life.
 And
 I
 don't
 think
 that's
 I
 don't


think
 it's
 a
 trade-off
 that
 anyone


should
 make
 at
 any
 point
 in
 time
 because


there
 there's
 more
 to
 life
 than
 working


in
 a
 company.
 And
 and
 that
 is
 that
 is


not
 the
 thing
 that
 you
 should
 be
 putting


on
 your
 flag,
 which
 has
 such
 a
 negative


connotation
 because
 of
 exactly
 what
 it


did.
 um
 where
 people
 literally
 kill


themselves
 over
 it,
 right?
 And
 like
 if


if
 you
 want
 to
 be
 a
 high
 intensity
 work


environment
 and
 say
 that
 but
 but
 but
 be


be
 more
 because
 in
 practical
 terms
 you


cannot
 be
 a
 company
 that
 that
 runs
 like


that.
 You
 can
 only
 be
 a
 company
 where


high
 energy
 people
 work
 and
 they
 build


themselves
 up.
 But
 there's
 a
 limit
 to


which
 you
 can
 do
 it
 and
 you
 have
 to
 be


transparent
 about
 what
 the
 cost
 of
 this


is.
 And
 I've
 been
 in
 the
 tree
 long


enough
 that
 I
 I've
 seen
 many
 many many


bad
 outcomes.
 And
 in
 particular
 through


my
 community,
 a
 lot
 of
 people
 even
 went


down
 like
 psychosis
 and
 schizophrenia


and
 a
 bunch
 of
 things
 where
 your


likelihood
 of
 going
 down
 that
 also


increases
 during
 certain
 years
 with


unhealthy
 behavior.
 Now
 having
 worked
 at


at
 Centu
 which
 is
 all
 about
 error


handling
 or
 at
 core
 is
 there
 you've


probably
 seen
 tons
 of
 stats
 on
 on
 most


common
 errors
 uh
 that
 that
 are
 coming
 up


in
 in
 different
 uh
 servers.
 What
 have


you
 learned
 about
 error
 handling
 and
 how


to
 build
 better
 software
 with
 fewer


errors
 from
 a
 developer
 perspective?
 So


the
 biggest
 thing
 that
 I
 learned
 um
 and


ironically


hasn't
 really
 dramatically
 shifted


despite
 the
 existence
 of
 tools
 like


Sentry
 and
 their
 popularity
 is
 that
 many


of
 the
 ways
 in
 which


errors
 are
 worked
 with


um
 just
 doesn't
 carry
 enough
 information


or
 only
 carries
 useful
 information
 for


debugging
 in
 debug
 builds.
 And


that's
 problematic
 because
 the
 most


interesting
 errors
 don't
 happen
 in


debug,
 right?
 Um
 now
 maybe
 this
 is


changing
 a
 little
 bit
 with
 um
 with
 AI


because
 like
 the
 cost
 of
 producing
 a


reproducer
 from
 not
 perfect
 information


might
 go
 down.
 So
 so
 that
 that
 maybe


there's
 a
 counter
 move
 to
 that.


I
 I
 really
 felt
 that
 as
 a
 language


designer,
 as
 a
 VM
 creator,
 you
 put


should
 put
 a
 lot
 more
 emphasis
 on
 making


sure
 that
 the
 errors
 can
 carry
 really


useful
 information
 rather
 cheaply
 even


in
 release
 and
 in
 production
 runs.
 And


so


not
 a
 lot
 of
 ecosystems
 don't
 do
 that,


which
 is
 which
 is
 very
 sad.
 And
 and
 I


think
 that
 the
 fact
 that
 Python
 had
 such


great
 introspectability
 without
 further


like
 Python
 is
 a
 slow
 language.
 So
 if


you
 already
 for
 all
 your
 debugging
 tools


added,
 it
 doesn't
 get
 significantly


slower.
 That
 actually
 was
 the
 reason


Centry
 existed
 because
 Sentry
 was
 able


to
 show
 local
 variables
 for
 Python.
 it


it
 had
 all
 this
 rich
 powerful
 data
 that


for
 many
 languages
 even
 today
 we're
 not


able
 to
 do
 because
 the
 runtime
 doesn't


support
 it
 or
 or
 the
 the
 the
 runtime
 uh


effect
 of
 doing
 that
 is
 too
 high
 and
 so


that's
 the
 thing
 that
 I
 learned
 the
 most


is
 like
 your
 your
 experience
 of
 of


debugging
 issues
 is
 so
 much
 better
 if


you
 have
 rich
 um
 rich
 information
 errors


and
 unfortunately
 both
 language


languages
 language
 creators
 uh
 runtimes


often
 neglect
 errors.
 So
 they
 don't


carry
 the
 right
 information
 and
 the


application
 and
 library
 developers
 often


don't
 think
 about
 errors
 at
 all
 or
 or


they
 they
 captured
 them
 down
 in
 the


wrong
 places
 and
 then
 the
 useful
 stack


trace
 is
 gone.
 All
 that
 sort
 of
 stuff


because
 you
 think
 they're
 exceptional.


They're
 not
 happening
 all
 that
 often,


but
 unfortunately
 every
 time
 they
 did


happen,
 you
 know,
 you
 didn't
 have
 enough


data.
 Um
 so
 like
 just
 in
 general
 like


the
 design
 of
 errors
 is
 completely
 uh
 is


not
 where
 it
 should
 be
 given
 how


important
 they
 are.


>> So
 that's
 one
 thing
 but


Sentry
 works
 across
 a
 bunch
 of
 different


languages
 almost
 all
 languages
 right


these
 days
 or
 or
 at least
 the
 ones
 that


that
 can
 that
 are
 widely
 used.
 Have
 you


seen
 interesting
 patterns
 between
 the


types
 of
 errors
 or
 the
 frequency
 of


errors
 of
 of
 using
 languages?
 Basically,


I'm
 trying
 to
 get
 to
 like
 how
 important


it
 is
 is
 it
 to
 choose
 your
 language
 in


terms
 of,
 you
 know,
 like
 having
 more


correct
 programs?


>> Well,
 different
 languages
 crash
 in


different
 ways
 and
 not
 just
 because
 of


the
 language,
 but
 also
 what
 you
 build


with
 it.
 And
 so
 for
 instance,
 JavaScript


at
 scale
 like
 if
 you
 look
 at
 a
 lot
 of


websites


errors
 all
 the
 time


the
 percentage
 of
 errors
 in
 JavaScript


that
 actually
 are
 like
 meaningful
 is


very
 very
 low.


>> Yeah.
 Like
 I
 whenever
 I
 open
 up
 my
 my
 my


deep
 you
 know
 developer
 tools
 and
 it
 it


then
 it
 shows
 you
 the
 errors
 and


warnings
 and
 like
 every
 single
 website


or
 almost
 every


>> and
 that
 makes
 sense
 because
 you
 you


very
 few
 errors
 that
 you
 can
 actually


cause
 in
 JavaScript
 and
 crash
 a
 browser


tab
 for
 instance
 right
 so
 it's
 like


you're
 you're
 it's
 like
 on
 error
 resume


next
 you're
 hobbling
 along
 like


something
 is
 broken
 but
 doesn't
 really


like
 but
 like
 the
 the
 existence
 of
 an


error
 in
 the
 in
 the
 console
 log
 doesn't


imply
 that
 the
 website
 is
 broken
 but
 for


instance
 like
 might
 like
 now
 the
 event


listener
 might
 not
 fire
 anymore.
 So
 the


the
 click
 is
 a
 dead
 click
 which
 is


something
 that
 sentry
 needed
 a
 session


replay
 product
 to
 find
 because
 the
 the


actual
 error
 that
 you
 would
 find
 in


sentry
 was
 insufficiently
 linked
 to
 user


not
 being
 advanced
 on
 the
 page.
 On
 the


other
 hand,
 if
 you
 have
 a
 computer
 game


it's
 written
 C++
 and
 it
 crashes
 your


session
 is
 over,
 right?
 And
 so
 the
 there


are
 comparatively
 fewer
 crashes
 in


queria
 games
 compared
 to
 all
 the


nonsense
 going
 in
 JavaScript,
 but
 when


they
 do
 happen,
 they're
 much
 more


meaningful.
 And
 so
 it's
 very
 hard
 to
 say


like
 error
 rates
 in
 different
 languages


and
 so
 forth
 because
 like
 the
 impact


that
 these
 errors
 have
 is
 very
 very


different.
 So
 C++
 code
 crashes
 in


computer
 games
 shockingly
 little.
 like


the
 the
 amount
 of
 traffic
 that
 Centry


gets
 from
 these
 is
 very
 very
 low,
 but


the
 usefulness
 of
 each
 individual
 crash


report
 in
 C++
 is
 so
 much
 higher.
 So
 it's


just
 it's
 it's
 a
 very
 complex
 topic
 at


scale
 to
 say
 like
 how
 does
 something


error
 because
 it
 really
 depends
 on
 like


what
 does
 it
 take
 down.
 Um
 obviously


there
 are
 certain
 types
 of
 errors
 that


you
 if
 you
 see
 them
 long
 enough
 you
 feel


like
 they
 really
 shouldn't
 happen.
 To


some
 degree
 there
 was
 a
 a
 large
 scale


realization
 in
 the
 JavaScript
 ecosystem


that
 type
 checkers
 could
 get
 rid
 of
 a


whole
 bunch
 of
 class
 of
 errors
 because


at
 the
 very
 least
 you
 have
 to
 explicitly


check
 if
 this
 thing
 is
 nullable
 or
 not.


But
 I
 I
 also
 didn't
 ever
 get
 the
 feeling


that
 the
 adoption
 of
 Typescript
 would


dramatically
 change
 anything
 about
 like


centuries
 JavaScript
 error
 rates.
 If


anything
 it
 like
 none
 of
 that
 adoption


had
 any
 meaningful
 impact
 on
 on
 how
 cry


Yeah.
 Well,
 because
 because
 what
 what


what
 what
 I
 would
 have
 expected,
 right?


Like
 we
 know
 and
 I
 think
 it's
 pretty


commonly
 assumed.
 I'm
 not
 sure
 if
 it's


proven
 that
 type-
 safe
 languages
 will


reduce
 certain
 kind
 of
 more
 obvious


errors.
 TypeScript
 does
 this
 with


JavaScript.
 I
 mean,
 it
 has
 a
 compiler,


but
 but
 in
 the
 end,
 you
 you
 do
 get
 a
 a


check
 before
 it
 all
 gets
 compiled
 to


JavaScript.
 So,
 we
 should
 have
 fewer.


That's
 what
 that's
 what
 I
 think.
 So


you're
 saying
 that
 you
 didn't
 really
 see


uh
 too
 much
 change?


>> No,
 I
 I
 I
 if
 if
 there
 was
 an
 impact
 is


unmeasurable.
 Um
 and
 then
 of
 course
 you


have
 like
 you
 have
 you
 have
 other
 sort


of
 frequency
 functions
 that
 might
 happen


that
 that
 offset
 what
 like
 maybe


whatever
 improvement
 that
 you
 have
 on


like
 catching
 like
 some
 of
 those
 you


maybe
 that
 sort
 of
 makes
 you
 just
 more


adventurous
 to
 build
 more
 complex
 code


in
 comparison.
 Right.
 A
 lot
 of
 the
 time


of
 century
 was
 the
 SER
 era
 of
 crazy


complexity
 and
 so
 then
 um
 like
 many
 of


the
 errors
 were
 related
 to
 not
 like
 did


I
 was
 this
 nullable
 or
 not
 but
 now
 the


sudden
 it's
 a
 microser
 that
 I'm
 talking


to
 and
 they
 have
 misaligned
 versions
 and


my
 type
 check
 actually
 didn't
 help
 me
 at


all
 because
 someone
 decided
 that
 on
 a


network
 layer
 it's
 now
 null
 anyways


right
 so
 the
 the
 comp
 the
 increased


complexity
 of
 many
 of
 the
 software
 that


centry
 dealt
 with
 over
 the
 years.
 I


think
 you
 could
 have
 probably
 measured


that
 especially
 I
 remember
 the
 adoption


of
 um
 of
 of
 more
 and
 more
 complex
 things


in
 the
 in
 the
 React
 ecosystem
 uh
 just


dramatically
 increased
 the
 the
 types
 of


errors
 like
 at
 one
 like
 hydration
 errors


were
 not
 a
 thing
 for
 many
 years
 and
 then


all
 of a
 sudden
 there's
 a
 whole
 class
 of


new
 errors
 coming
 in
 because
 the
 now
 all


of a
 sudden
 the
 view
 stability
 between


initial
 server
 render
 and
 what
 the


JavaScript
 dynamically
 loaded
 on
 time


does
 it's
 like
 that
 was
 an
 whole
 class


of
 errors
 that
 didn't
 exist
 before
 and


all
 of a
 sudden
 does
 exist,
 right?
 So,


it's
 very
 hard
 to
 measure
 these
 things


just
 because
 of
 how
 we
 change
 and
 how


much
 more
 complex
 our
 apps
 are.


>> Yeah.
 So,
 so
 so
 like
 you're
 saying


that's
 true
 like
 before
 React
 and
 you


know
 like
 hydration
 errors
 are
 specific


to
 React.
 But
 those
 that
 whole
 error


category
 just
 didn't
 exist
 and
 then
 as


React
 spread
 they're
 kind
 of
 pretty


common
 in
 in
 React.
 So
 so
 now
 you
 get


technically
 you
 get
 more
 errors.
 Is
 it


is
 it
 turns
 out
 to
 be
 a
 very
 safe


business
 to
 be
 in
 errors
 because
 they're


not
 really
 going
 down.


>> Yeah.
 Well,
 and
 then
 I
 I
 think
 we're


going
 to
 extrapolate
 it
 obviously
 with


AI
 tools
 using
 typically
 using
 the
 most


popular
 frameworks
 or
 the
 ones
 that
 has


the
 most
 training
 data
 which
 is
 the
 most


popular
 ones.
 So
 we're
 we're
 follow
 and


we'll
 we'll
 we'll
 likely
 see
 an


explosion
 of
 code
 and
 deployments.
 So


yeah,
 it's
 probably
 good
 good
 business.


But
 having
 been
 in
 the
 the
 errors


business,
 how
 did
 you
 change
 your
 your


your
 or
 the
 teams
 the
 team
 centry?
 How


did
 you
 change
 your
 approach
 to
 building


software
 with
 errors
 in
 mind?
 Were
 you


more
 aware
 of
 it?
 Did
 anything
 change
 at


all?
 Cuz
 it's
 interesting,
 you
 know,
 you


you've
 had
 such
 good
 insight
 into
 like


all
 the
 I'm
 going
 to
 say
 mistakes.
 They


might
 not
 be
 mistakes,
 but
 we
 can
 say,


you
 know,
 error
 is
 generally
 not
 a


positive
 thing,
 but
 you've
 seen
 all


these
 things
 come
 through.
 So,
 did
 you


change
 how
 we
 develop
 software?
 Hey,
 you


would
 think
 that
 working
 at


observability
 company
 makes
 it
 great
 at


building
 observable
 com
 products
 and
 and


the
 reality
 is
 that
 there's
 a
 reason


errors
 are
 an
 afterthought,


right?
 It's
 like
 you
 you
 almost
 have
 to


force
 yourself
 to
 take
 care
 of
 this
 5%


case
 or
 1%
 case,
 right?
 And
 that's
 a


that's
 that's
 a
 continued
 problem
 like


every
 pull
 request
 in
 a
 way
 you
 like
 now


it
 passes.
 So
 we
 have
 dealt
 with
 this


like
 are
 you
 going
 to
 put
 the
 extra
 time


in
 to
 also
 make
 sure
 that
 even
 if
 if
 it


like
 now
 fails
 that
 it
 reports
 the
 error


correctly.
 I
 I
 don't
 think
 that
 centric


code
 is
 more
 correct
 for
 error
 reporting


than
 any
 random
 other
 code
 out
 there
 is


because
 the
 act
 of
 taking
 care
 of
 good


error
 reporting
 is
 a
 deliberate
 act.
 Um


the
 act
 of
 like
 good
 logging
 is
 a


deliberate
 act.
 The
 act
 of
 good
 metric


supporting
 is
 a
 deliberate
 act.
 And
 you


will
 train
 that
 muscle
 a
 little
 bit
 over


time,
 but
 I
 think
 like
 you
 you
 maybe
 get


50%
 better,
 100%
 better
 at
 it,
 which
 is


still
 very
 very
 low.
 We
 should
 get
 like


a,000%
 better.
 Like
 it's
 like
 that


that's
 where
 we
 would
 see
 the
 like
 the


improvements.
 Like
 if
 if
 every
 sing
 like


if
 90%
 of
 errors
 are
 really
 like
 error


cases
 are
 really
 well
 reported
 like
 like


that
 would
 be
 really
 good.
 But
 like


that's
 a
 really
 massive
 lift.
 And
 you


would
 only
 really
 get
 this
 lift
 if
 you


stop
 programming
 like
 we
 are.
 and
 maybe


the
 languages
 themselves
 have
 like


pulling
 this
 into
 every
 stack
 frame
 into


every
 sort
 of
 corner
 case.
 So
 I
 think


that
 the
 real
 lift
 would
 come
 if
 a
 bunch


of
 people
 that
 now
 build
 these


observability
 companies
 say
 like
 okay


now
 that
 we
 know
 what
 what
 our
 problem


is
 which
 is
 data
 collection
 in
 the
 first


place.
 How
 do
 we
 build
 a
 programming


environment
 that
 makes
 this
 native?


Right?
 For
 many
 many
 years,
 the
 biggest


challenge
 for
 for
 just
 bringing


awareness
 of
 what
 we're
 doing
 was
 uh
 was


context
 local.


>> What
 what
 what
 is
 context
 local?


>> There's
 a
 there's
 an
 excellent
 talk
 by


Ron
 Presler
 who
 wrote
 uh
 the
 I
 think
 the


original
 implementation
 of
 virtual


threats
 for
 Java
 who
 later
 um
 worked
 on


the
 Loom
 project
 to
 bring
 virtual


threats
 straight
 into
 Java.
 basically


made
 a
 strong
 argument
 for
 the
 stacked


frame.
 Like
 what's
 so
 great
 about
 stack


frames?
 Like
 stack
 frames
 are
 amazing


because
 they
 carry
 information
 basically


implicitly
 with
 it.
 Um
 and
 he
 he
 sort
 of


demonstrated
 what
 you
 give
 up
 if
 you


move
 to
 async
 weight
 where
 you
 basically


chain
 together
 a
 bunch
 of
 promises
 to


each
 other.
 And
 the
 the
 the
 the


immediate
 problem
 that
 we
 have
 if
 you


start
 moving
 towards
 promises
 is
 that


now
 it's
 very
 hard
 to
 carry
 through


information
 through
 all
 of
 the
 potential


paths
 that
 this
 promise
 chain
 would
 take


you.
 So
 for
 instance,
 if
 you
 want
 to
 say


like
 I
 have
 a
 correlation
 ID
 which


should
 be
 attached
 to
 every
 single
 log


event,
 it
 should
 be
 attached
 to
 every


single
 error
 event.
 That
 might
 happen
 as


a
 result
 of
 this
 original
 thing
 I'm


doing
 with
 ST
 frames.
 Super
 trivial.


It's
 sitting
 somewhere
 in
 the
 stack.
 I


will
 not
 lose
 it.
 I
 can
 walk
 up
 the


stack
 and
 find
 it
 again.
 But
 with
 with


with
 promises
 now
 I
 need
 to
 I
 need
 to


have
 this
 chain
 together.
 And
 so
 context


locals
 is
 is
 what
 is
 called
 in
 some


languages.
 In
 .NET
 it's
 called
 the


execution
 context.
 It's
 basically
 a


hidden
 piece
 of
 almost
 like
 a
 threat


local
 but
 a
 much
 more
 narrow
 scoped
 one


which
 flows
 with
 the
 logical
 flow
 of


execution.
 And
 why
 is
 this
 necessary?


Because
 if
 you
 do
 something
 like
 open


telemetry,
 if
 you
 do
 tracing,
 if
 you
 do


things
 like
 you
 want
 to
 have
 a


correlation
 ID,
 you
 want
 to
 have
 it
 show


up
 everywhere,
 right?
 And
 for
 many
 years


a
 century,
 it
 was
 like
 just
 talking
 to


people
 like,
 hey,
 you
 know
 what
 would
 be


really
 great
 to
 have
 context
 locos


everywhere.
 And
 JavaScript
 um
 I
 think
 in


a
 browser
 still
 doesn't
 have
 them
 in
 in


the
 back
 end.
 It
 eventually
 got
 uh


domains
 initially,
 then
 it
 got
 async


hooks
 and
 nowadays
 it's
 called
 async


local
 storage.
 It
 sounds
 like
 to
 me
 like


as
 you
 said
 like
 as
 an
 engineering
 team


let's
 say
 even
 even
 at
 Sentry
 you
 kind


of
 your
 focus
 is
 to
 get
 the
 thing
 done.


You
 know
 you
 test
 that
 it
 works


correctly
 and
 then
 when
 it
 comes
 to
 like


errors
 as
 you
 said
 it's
 kind
 of
 usually


an
 afterthought
 either
 when
 it
 blows
 up


or
 you
 know
 if
 if
 if
 you've
 got
 a
 lot
 of


time
 or
 you
 really
 need
 to
 make
 it
 sure


that
 that
 it's
 it's
 going
 to
 work


correctly.
 But
 with
 languages,


programming
 languages,
 it
 almost
 sounds


ironically
 that
 it
 in
 many
 languages,


it's
 an
 afterthought
 because
 as
 you


said,
 if
 you
 thought
 it
 through
 better


saying,
 hey,
 at
 some
 point
 the


programmer
 will
 crash
 or
 there
 will
 be


an
 error.
 What
 can
 I
 do?
 And
 you
 know,


there's
 a
 context
 local
 thing
 that
 you


talked
 about.


>> I
 don't
 think
 it's
 an
 afterthought.
 I


think
 it's
 deliberately
 not
 done
 because


you
 have
 to
 imagine
 like
 there
 there
 are


different
 kind
 of
 forces
 in
 a


programming
 language
 that
 say
 like
 what


should
 the
 language
 do
 and
 some
 of
 them


are
 very
 clearly
 at
 odds
 with
 each


other.
 So
 why
 what's
 the
 problem
 with


context
 locals?
 Why
 they
 make
 every
 call


slower,
 right?
 So
 now
 it's
 like
 all
 the


people
 that
 want
 a
 faster
 language,


they're
 like,
 well,
 now
 you
 got
 to
 make


a
 really
 strong
 argument
 why
 you
 should


be
 doing
 this.
 I
 remember
 one
 of
 the
 the


biggest
 fights
 over
 the
 years
 that
 sort


of
 hidden
 was
 hidden
 behind
 the
 scenes


was
 um
 on
 native
 platforms,
 compilers
 at


one
 point
 made
 a
 decision
 that
 we
 can


get
 one
 extra
 register
 by
 basically


using
 the
 it's
 called
 a
 stack
 register.


you
 would
 basically
 you
 would
 give
 up


the
 last
 register
 to
 to
 recover
 the
 ST


frame
 for
 one
 extra
 register
 for
 other


users
 and
 then
 you
 would
 have
 to
 use
 a


very
 complex
 uh
 dwarf
 unwinding
 system


to
 recover
 this.
 Right?
 So
 you
 you


basically
 say
 like
 we're
 moving
 some
 of


the
 complexity
 of
 being
 able
 to
 just
 at


runtime
 walk
 for
 the
 stack
 to
 doing
 it


delayed
 through
 a
 very
 complicated
 uh


binary
 program
 which
 is
 embedded
 in
 this


debug
 information
 file.
 But
 what
 do
 you


lose
 through
 this?
 Well,
 you
 lose


runtime
 profiling
 capabilities
 because


that's
 too
 slow
 to
 do
 at
 scale.
 So,
 it


can't
 do
 an
 inprocess
 profiler,
 which


turns
 out
 to
 be
 incredibly
 useful


because
 you
 you
 will
 you
 will
 find


information
 you
 wouldn't
 find
 through
 uh


through
 tracing,
 right?
 Um
 you
 can
 do


like
 um
 basically
 can
 you
 can
 run
 a


sampling
 profiler.
 Um,
 it
 also
 made
 it


incredibly
 hard
 for
 Sentry
 to
 do
 proper


stack
 reports
 for
 um,
 native
 code


because
 I
 I
 might
 not
 be
 able
 to
 recover


the
 debug
 symbol
 because
 it's
 a
 it's
 a


binary
 driver
 from
 someone
 and
 nobody


ever
 gave
 me
 the
 the
 DLS.


>> Yeah,
 you
 don't
 have
 a
 source
 code
 or


the
 mappings.
 I


>> I
 know
 like
 Facebook
 for
 instance,


Facebook's
 app
 um,
 secretly
 uploaded


Android
 system
 symbols
 all
 the
 time.


like
 your
 your
 device
 were
 randomly


assigned
 if
 it
 should
 upload
 it
 or
 not


and
 they
 were
 harvesting
 all
 the
 system


symbols
 to
 increase
 the
 quality
 of
 the


error
 reporting
 like
 if
 your
 Facebook


scale
 can
 do
 that
 like
 sentry
 couldn't


do
 that
 like
 we
 can't
 just
 magically


have
 every
 sentry
 SDK
 just
 upload
 a


bunch
 of
 files
 just
 that
 would
 just


destroy
 user
 trust
 but
 eventually
 and
 I


think
 that
 only
 took
 place
 two
 years
 ago


someone
 at
 I
 think
 it
 was
 Debian
 or
 or


Redhead
 was
 like
 well
 this
 is
 nonsense


we're
 going
 to
 change
 this
 now
 we're


going
 to
 bring
 the
 ST
 pointer
 back
 and


it
 was
 a
 fight.
 It
 was
 a
 fight
 to
 do
 it


and
 they
 was
 like,
 well,
 we
 we we


benchmarked
 all
 of
 it.
 We're
 just
 using


5%.
 Except
 for
 Python
 where
 the
 Python


interpreter
 for
 whatever
 reason
 got
 like


20%
 slower.
 So,
 they
 didn't
 do
 it
 for


Python.
 But
 but
 the
 it
 was
 it
 was
 one


flag,
 right?
 It's
 one
 flag
 and
 but
 what


matters
 is
 that
 flag
 is
 set
 by
 default


to
 everything,
 right?
 So,
 it
 should
 be


on
 by
 default.
 But
 but
 this
 5%
 of


performance
 difference
 which
 was
 assumed


to
 be
 more
 than
 that,
 there
 was
 a


year-long
 pressuring,
 right?
 So
 I
 I


think
 it's
 hard
 to
 do
 because
 you
 have


these
 different
 interests
 in
 it
 and
 some


people
 want
 the
 performance
 and
 some


people
 want
 the
 debugability
 and
 and


they
 they
 might
 live
 in
 completely


different
 worlds
 like
 maybe
 this
 one


person
 that
 really
 cares
 about


performance
 just
 never
 has
 to
 look
 at


any
 crashes
 because
 that's
 not
 the
 area


of
 responsibility
 and
 then
 you
 have


someone
 who
 maintains
 a
 fleet
 of
 complex


services
 and
 every
 one
 of
 them
 has
 a


small
 percentage
 of
 crashing
 and
 often


doesn't
 run
 the
 code
 that
 they
 have
 and


then
 once
 they
 have
 the
 crash
 they
 don't


have
 the
 data
 that
 they
 need.


>> This
 this
 is
 so
 interesting
 because
 it


it
 just
 it
 it
 reminds
 you
 of
 how


difficult
 it
 must
 be
 to
 design
 a


language
 because
 again
 you
 have
 so
 many


users
 and
 as
 you
 say
 the
 the
 person
 who


just
 had
 a
 crash
 they
 actually
 want


ideally
 the
 language
 support
 to
 get
 that


back
 in
 a
 very
 easy
 way
 but
 now
 it
 will


by
 by
 default
 slow
 it
 down
 either
 either


through
 performance
 or
 through
 higher


memory
 usage
 like
 you
 cannot
 have
 a
 free


lunch
 right?
 Yeah,
 it
 looks
 like
 the


lunch
 comes
 with
 some
 price.
 But
 look,
 I


have
 a
 I
 have
 a
 lot
 more
 respect
 now
 I


think
 for
 for
 language
 designers
 just


because
 of
 you
 like
 especially
 if
 you


start
 out
 programming
 you
 have
 this


naive
 idea
 of
 like
 it
 has
 to
 work
 this


way,
 right?
 Um
 and
 then
 you
 and
 then


over
 time
 you
 realize
 oh
 there
 are
 all


these
 trade-offs
 you
 have
 to
 make
 and


some
 of
 them
 are
 really
 hard
 to
 quantify


and
 you
 might
 even
 have
 to
 make
 some


very
 unpopular
 decisions
 and
 there's
 no


real
 right
 or
 wrong.
 There
 just
 a
 lot
 of


trade-offs
 and
 maybe
 this
 is
 also
 why
 we


have
 so
 many
 languages
 to
 some
 degree.


But
 it
 is
 very
 fascinating
 to
 think


about
 what
 some
 of
 these
 seemingly


little
 defaults
 have
 in
 terms
 of
 what


you
 can
 do
 with
 it
 and
 then
 maybe
 what


kind
 of
 people
 are
 going
 to
 pick
 your


language.
 I
 thought
 Python
 was
 the
 most


amazing
 language
 ever
 for
 building
 web


services
 because
 I
 could
 I
 could
 inspect


every
 process
 and
 it
 didn't
 make
 it
 any


slower.
 But
 now
 I
 know
 that's
 also
 why


Python
 was
 slow
 to
 begin
 with,
 right?


And
 so


>> what
 are
 some
 things
 that
 you've
 learned


being
 an
 early
 engineer
 almost
 like
 a


founding
 engineer
 at
 a
 startup
 and
 what


is
 advice
 that
 you
 would
 give
 to
 an


engineer
 joining
 a
 startup
 a
 fast


growing
 startup
 uh
 right
 now
 early
 on


>> well
 I
 can
 I
 can
 give
 the
 advice
 from


someone
 who
 would
 have
 joined
 the


company
 10
 years
 ago
 right
 um
 look
 the


situation
 changes
 all
 the
 time
 I
 think


but
 my
 life
 in
 many
 ways
 is
 a
 a
 very


linear
 path
 where
 like
 there's
 an


opportunity
 I
 make
 a
 decision
 if
 I
 take


it
 or
 not
 it's


the
 secretary
 problem,
 but
 I'm
 kind
 of


taking
 not
 too
 many
 attempts
 of
 it,


right?
 Which
 is
 like
 I
 I
 just
 want
 to


like
 the
 the
 passing
 bar
 for
 me
 is
 do
 I


think
 that
 this
 is
 great?
 Do
 I
 want
 to


work
 on
 it?
 And
 then
 maybe
 I
 take
 the


opportunity
 to
 work
 on
 it.
 And
 for
 for


me
 in
 particular,
 I'm
 I'm
 shaped
 like
 a


person
 that
 is
 actually
 not
 a
 great


employee


because
 I
 don't
 necessarily
 go
 and
 fit
 a


particular
 mold.
 my
 titles
 at
 century
 in


many
 ways
 over
 the
 years
 were


I
 I
 didn't
 even
 associate
 with
 them
 in
 a


way
 right
 it's
 like
 at
 one
 point
 it
 said


I
 don't
 know
 software
 engineer
 on
 it
 but


I
 was
 like
 responsible
 for
 an
 office


here
 with
 people
 underneath
 where
 I


sometimes
 felt
 like
 I'm
 a
 payroll


provider
 right
 like
 there
 were
 so
 many


other
 things
 in
 it
 because
 like
 a
 small


startup
 has
 this
 many
 like
 now
 someone


needs
 to
 deal
 with
 this
 stuff
 too
 right


like
 you
 need
 to
 hire
 someone
 to
 even


just
 bring
 dumb
 things
 like
 just


furniture
 into
 the
 place.
 If
 you
 join
 a


company
 early,
 everything
 is
 in
 flux.


Nothing
 is
 well
 defined.
 And
 some
 people


like
 that,
 some
 people
 don't
 like
 that.


And
 I
 think
 you
 have
 to
 be
 just
 willing


to
 experience
 new
 things.
 If
 you
 start


at
 a
 scrappy
 startup
 that
 particularly


maybe
 comes
 from
 someone
 who
 hasn't


founded
 a
 company
 before,
 hasn't
 been


there
 when
 a
 company
 sort
 of
 grew
 from


small
 to
 big
 because
 even
 now
 for
 me
 I


just
 realize
 again
 oh
 I
 kind
 of
 forgot
 I


need
 to
 do
 all
 of
 this
 and
 this
 again.


Um
 but
 but
 that's
 uh
 if
 there
 are
 people


that
 like
 that
 and
 people
 don't
 like


that
 and
 and
 you
 just
 have
 to
 be
 aware


of
 of
 the
 consequence
 of
 this
 and
 you


have
 to
 path
 the
 way
 for
 yourself


somehow
 either
 by
 being
 okay
 with
 just


doing
 whatever
 comes
 up
 or
 being


incredibly
 ambitious
 and
 deliberately


taking
 certain
 paths
 towards
 where
 you


want
 to
 go
 even
 if
 that
 might


temporarily
 set
 you
 back
 in
 one
 form


another.
 And
 now
 you're
 the
 one
 who


started
 a
 startup
 as
 a
 as
 a
 as
 a


software
 engineer.
 Uh
 you
 founded
 your


your
 startup
 with
 with
 your
 co-founder


so
 far.
 How
 is
 it
 going?
 And
 how
 is
 it


different
 to
 what
 you've
 expected


especially
 that
 you
 were
 on
 the
 other


side,
 right?
 You
 were
 an
 early
 uh


employee
 inside
 a
 startup.
 You've
 seen
 a


lot
 of
 things.
 Is
 it
 kind
 of
 like,
 you


know,
 exactly
 as
 you
 expected
 or
 or
 is


it
 just
 a
 different
 feeling?
 In
 in
 some


ways
 I
 I
 postponed
 the
 founding
 of
 the


company


many
 times
 right
 in
 my
 mind
 at
 least
 my


recollection
 of
 early
 century
 was
 like


well
 there
 could
 have
 been
 a
 path
 where


we
 didn't
 do
 century
 we
 did
 something


else
 right
 um
 and
 then
 after
 almost
 like


four
 or
 five
 years
 already
 like
 I


remember
 like
 when
 my
 first
 um
 like


where
 all
 my
 shares
 wested
 I
 was
 like
 hm


is
 is
 there
 a
 path
 where
 because
 there


was
 also
 versel
 was
 coming
 out
 at
 one


point
 where
 b
 took
 nextjs


and
 build
 an
 entire
 business
 around
 like


hey
 is
 there
 is
 there
 a
 path
 where
 you


could
 take
 actually
 something
 like
 flask


and
 and
 and
 build
 a
 thing
 around
 it.
 So


in
 some
 ways
 there
 was
 like
 a
 multi-year


preparation
 for
 me.
 So
 now
 it
 doesn't


feel
 like
 oh
 it's
 actually
 different.


It's
 just
 like
 okay
 that's
 the
 next


logical
 step
 kind
 of
 no
 I
 wouldn't
 call


them
 missteps
 but
 knowing
 some
 of
 the


decision
 we
 have
 made
 at
 century
 I
 can


now
 look
 at
 them
 and
 sort
 of
 look
 them


from
 a
 different
 perspective.
 Um
 I
 have


different
 opinions
 now
 about
 the
 equity


um
 about
 the
 consequences
 of
 equity
 um


how
 to
 structure
 certain
 things
 like


this
 time
 around
 basically
 I
 didn't


start
 with
 here's
 an
 idea
 for
 like
 a


product
 I
 want
 to
 build
 I
 the
 reason
 I


ended
 up
 starting
 this
 company
 with
 a


co-founder
 is
 like
 we
 actually
 sat
 down


and
 said
 like
 hey
 what
 do
 we
 want
 a


company
 to
 be
 like
 why
 are
 we
 even
 in


here
 for
 it
 we
 already
 know
 that
 we
 like


we're
 the
 kind
 of
 people
 that
 want
 to


start
 a
 company
 but


this
 is
 just
 like
 that's
 not
 an
 end
 on


its
 health
 like
 there
 something
 should


come
 out
 of
 it
 right
 and
 so
 I
 didn't
 do


that
 last
 time
 I
 just
 rolled
 into
 it
 now


you
 can
 overthink
 it
 obviously
 right
 but


but
 it's
 also
 there
 were
 many
 moments


over
 the
 years
 at
 century
 where
 I
 felt


like
 well
 actually
 it
 would
 have
 been


great
 for
 us
 to
 think
 about
 some
 of


those
 things
 so
 now
 I'm
 thinking
 about


them
 in
 the
 beginning
 the
 experience


primarily
 puts
 you
 there
 I
 don't
 think


you
 can
 sort
 of
 start
 out
 and
 say
 like


I'm
 going
 to
 do
 this
 obviously
 you
 can


you
 can
 read
 a
 bunch
 of
 like
 stories
 of


people
 that
 started
 startups
 and
 then


you
 you
 listen
 to
 all
 the
 podcasts
 and


everything
 and
 you
 hopefully
 get
 a
 a


better
 sense
 of
 it
 and
 maybe
 some
 to


some
 degree
 overprepared.
 But
 having


gone
 through
 it
 yourself
 versus
 just


hearing
 from
 someone
 like
 I
 read
 a
 lot


of
 stuff
 about
 startups
 even
 2015,


right?
 I
 was
 like
 I
 was
 sort
 of
 addicted


to
 this
 to
 that
 thing
 and
 still
 it
 feels


very
 different
 now
 doing
 it
 versus
 if
 I


would
 have
 done
 it
 5
 years
 ago
 just


because
 of
 my
 own
 inner


um
 the
 experience
 of
 like
 how
 I
 feel


about
 all
 of
 this
 like
 which
 when
 I
 have


a
 level
 of
 urgency
 versus
 where
 I
 just


sit
 it
 out
 like
 that
 the
 experience
 kind


of
 puts
 you
 in
 a
 in
 a
 different
 position


I
 would
 have
 done
 otherwise.
 I
 don't


know
 if
 that's
 helpful
 but
 that
 that's
 I


think
 mostly
 how
 I
 feel.
 Well,
 I
 I
 mean


it
 it
 sounds
 like
 you
 can
 like,
 you


know,
 get
 all
 the
 opinions,
 read
 about


it,
 listen
 to
 the
 stories,
 but
 it'll
 be


different
 when
 you
 do
 it
 in
 the
 end,
 and


it's
 hard
 to
 tell
 what
 ways
 until
 you
 do


it.


>> Yeah.
 And
 it
 worked
 for
 some
 people,
 but


it
 wouldn't
 have
 worked
 for
 me.
 Like,


and
 no,
 no
 amount
 of
 reading
 of
 anything


would
 have
 sufficiently
 prepared
 me.


Some
 people
 it
 might,
 right?
 Like


particularly
 if
 you're
 well
 educated,


like
 a
 person
 grew
 up
 with
 the
 right


values
 to
 to
 to
 have
 this
 intrinsically


sort
 of
 put
 onto
 you.
 But
 that
 was
 not


my
 education,
 right?
 medication
 was
 like


just
 standard
 schooling
 bunch
 of


university
 and
 then
 there's
 there's
 a


whole
 world
 that
 I
 haven't
 been
 exposed


to
 that
 sort
 of
 I
 had
 to
 learn
 in
 one


form
 or
 another


>> and
 then
 just
 to
 close
 with
 some
 rapid


questions
 so
 I'll
 just
 ask
 and
 then
 you


tell
 me
 what
 comes
 up
 of
 the
 programming


languages
 which
 one
 is
 your
 favorite
 and


I'm
 really
 interested
 to
 hear


>> it's
 Python
 and
 uh
 two
 answers
 for
 why


uh
 one
 because
 it
 gave
 me
 the
 career


that
 I
 had
 and
 so
 there's
 obvious


obviously
 a
 lot
 of
 emotional
 attachment


to
 it,
 but
 also
 it
 is
 it
 is
 a
 bad


programming
 language
 for
 many
 many


aspects
 of
 like
 misdesigned
 and


whatever,
 but
 it
 is
 incredibly
 pragmatic


and
 I
 just
 like
 that
 and
 I
 kind
 of
 want


to
 point
 towards
 many
 of
 the
 things
 that


Kell
 Henderson
 did
 over
 the
 years.
 He


was
 the
 CTO
 at
 Flickr
 originally
 and


then
 Slack
 PHP
 guy,
 right?
 But
 um
 the


the
 the
 pragmatism
 in
 which
 he
 used
 PHP


was
 in
 many
 ways
 a
 pragmatism
 in
 which
 I


always
 like
 building
 product
 with
 Python


and
 and
 it's
 like
 you
 don't
 really
 care


if
 it's
 good
 or
 bad
 in
 that
 sense
 like


like
 what
 you
 can
 do
 with
 it
 and
 I
 could


do
 a
 lot
 with
 Python
 and
 I
 appreciate
 it


for
 this


>> and
 then
 what's
 a
 tool
 that
 you
 love


using
 and
 what
 does
 it
 do?


>> I
 will
 answer
 this
 as
 a
 not
 programmer.


A
 tool
 I
 love
 using
 is
 a
 screwdriver.


it
 screws.
 But
 the
 reason
 why
 I
 just


love
 it
 so
 much,
 and
 I
 think
 this
 one
 of


the
 things
 that
 I
 learned
 over
 the


years,
 like
 I
 never
 really
 had
 a
 good


electric
 screwdriver,
 and
 then
 when
 we


bought
 our
 apartment,
 I
 just
 bought


really
 good


tools,
 including
 a
 screwdriver.
 And
 it


has
 increased
 my
 my
 willingness
 to
 drill


holes
 and
 assemble
 furniture
 and


everything.
 And
 that
 by
 far
 is
 probably


the
 most
 favorite
 thing
 that
 I
 have
 now.


is
 just
 a
 really
 really
 good


well-manufactured
 screwdriver.


>> I
 I
 I
 wonder
 if
 there's
 a
 metaphor
 there


uh
 that
 will
 apply
 to
 to
 development
 as


well.
 Like
 you
 know,
 when
 you
 when
 you


have
 good
 tools,
 you're
 actually
 a
 lot


more
 motivated
 and
 willing
 and
 and


you're
 more
 adventurous
 as
 well.
 Well,


thank
 you
 for
 this
 chat.
 This
 was
 really


fun.


>> It
 was
 it
 was
 really
 nice
 talking
 about


it.
 One
 of
 the
 most
 interesting
 parts


about
 talking
 with
 Armen
 was
 how
 he
 went


from
 being
 very
 negative
 about
 AI
 6


months
 ago
 and
 now
 he's
 building
 his


startup
 with
 AI
 agents
 like
 Claw
 Code


and
 OpenAI
 Codeex.
 I
 see
 Armen
 as
 a
 very


pragmatic
 engineer
 and
 if
 he
 went


through
 this
 much
 of
 a
 change
 after


pushing
 himself
 to
 use
 these
 tools
 more,


it
 tells
 me
 that
 it's
 worth
 giving
 AI


coding
 tools
 some
 time
 and
 see
 how
 they


work
 for
 you.
 For
 more
 observations
 on


AI
 tooling
 trends,
 check
 out
 Deep
 Dies


in
 the
 Pragmatic
 Engineer,
 which
 are


linked
 in
 the
 show
 notes.
 If
 you've


enjoyed
 this
 podcast,
 please
 do


subscribe
 on
 your
 favorite
 podcast


platform
 and
 on
 YouTube.
 A
 special
 thank


you
 if
 you
 also
 leave
 a
 rating
 for
 the


show.
 Thanks
 and
 see
 you
 in
 the
 next