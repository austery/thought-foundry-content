[Speaker 0]: 今天郑重发布我的第一款产品就是这个独一无二的一对一视频通话平台。
[Speaker 0]: 欧洲 o o to o 是完全基于浏览器运行的，
[Speaker 0]: 不需要你安装任何东西，
[Speaker 0]: 直接点发起通话，
[Speaker 0]: 然后把这个网址发给你。
[Speaker 0]: 想要通话的对象，
[Speaker 0]: 两个人就可以在浏览器里面直接视频聊天了，
[Speaker 0]: 而且想聊多久就聊多久，
[Speaker 0]: 没有时间限制，
[Speaker 0]: 后续还会有增加更多的新功能。
[Speaker 0]: 比如说共享屏幕、
[Speaker 0]: 视频录制文件分享之类的，
[Speaker 0]: 敬请期待。
[Speaker 0]:  o to o 的地址就在屏幕上，
[Speaker 0]: 我也发在了视频的简介和评论区里。
[Speaker 0]: 欢迎大家现在就去试用，
[Speaker 0]: 你可以在任何电脑和手机上的浏览器打开，
[Speaker 0]: 所以这可以说是真正意义上的全平台覆盖。
[Speaker 0]: 这是因为我用到的都是原生的浏览器功能，
[Speaker 0]: 包括最核心的 web RTC 和 web socket 啊，
[Speaker 0]: 这些具体的技术细节。
[Speaker 0]: 待会我会有更详细的分享开发这个平台的一个初衷，
[Speaker 0]: 就是为了照顾我的那些社恐粉丝。
[Speaker 0]: 平时我在直播的时候就鼓励大家连麦咨询，
[Speaker 0]: 但是就没几个人敢连麦的一问，
[Speaker 0]: 都是说不好意思在那么多人面前说话。
[Speaker 0]: 也因为考虑到个人隐私，
[Speaker 0]: 我也没有加任何粉丝的微信或者是留电话号码，
[Speaker 0]: 所以一直找不到一个合适的一对一的聊天渠道。
[Speaker 0]: 孔子说过，
[Speaker 0]: 求人不如求己。
[Speaker 0]: 所以我干脆就自己造了一个，
[Speaker 0]: 说是自己造，
[Speaker 0]: 其实全程都是 AI 在写代码。
[Speaker 0]: 而我扮演的就是大家最讨厌的产品经理，
[Speaker 0]: 这个角色准备好工作环境，
[Speaker 0]: 定好工作要求，
[Speaker 0]: 然后等着验收产品。
[Speaker 0]: 而最终的部署环境是某个云服务商托管了 commmonintis 集群 REDS 和 POS gres 实力。
[Speaker 0]: 以上这些都是我现有的资源。
[Speaker 0]: 所以整一个项目并没有增加什么额外成本，
[Speaker 0]: 主打的就是一个勤俭节约。
[Speaker 0]: 那么有观众可能就会问了，
[Speaker 0]: 你这不是一个视频通话平台吗？
[Speaker 0]: 视频通话的带宽消耗难道不算成本吗？
[Speaker 0]: 那这就要说到我选择的技术上了。
[Speaker 0]: 从初始的 pompt 可以看到，
[Speaker 0]:  web RTC 等原生的浏览器 API 是我的核心功能。
[Speaker 0]:  maps real time communications 是二零一一年就成为 dba 三 c 标准的网页。
[Speaker 0]: 即时通讯 API 它可以让两个浏览器进行端对端的音视频传输，
[Speaker 0]: 而服务器就只需要帮忙同步一下双方的信息。
[Speaker 0]: 所以我的后端就只需要提供非常基本的业务 API，
[Speaker 0]: 以及用来同步的 web sock 接口。
[Speaker 0]: 而在一次视频通话里面，
[Speaker 0]: 这些接口最多只会消耗几十个 KB 的流量。
[Speaker 0]: 这里其实还有一个技术细节，
[Speaker 0]: 就是在 prompt。
[Speaker 0]: 最后，
[Speaker 0]: 我要求 AI 只提供 stand server，
[Speaker 0]: 不要提供 turn server。
[Speaker 0]:  ten 服务器是指通过公共的网络去进行双方 IP 地址的确认，
[Speaker 0]: 从而达成端对端的通信。
[Speaker 0]: 而在一些企业网络和校园网络里面，
[Speaker 0]: 公网的端对端是不被允许的。
[Speaker 0]: 所以这个时候就需要特人服务器作为一个中转站，
[Speaker 0]: 视频流都要从这个服务器上面流入流出。
[Speaker 0]: 这样我就要承担所有的带宽成本。
[Speaker 0]: 考虑到我这个 o to o 的使用场景，
[Speaker 0]: 最后我决定了不支持企业和校园这些复杂的网络，
[Speaker 0]: 所以选择了不提供 turn 服务器。
[Speaker 0]: 而这也是为什么，
[Speaker 0]: 我说你想聊多久就聊多久，
[Speaker 0]: 因为消耗的都是你的流量，
[Speaker 0]: 我无所谓。
[Speaker 0]: 那说到成本，
[Speaker 0]: 这个平台的开发成本也是非常低的。
[Speaker 0]: 我前面说花了十个小时，
[Speaker 0]: 实际上大部分时间都是 AI 在跑，
[Speaker 0]: 我只是偶尔做一下测试，
[Speaker 0]: 找找 bug。
[Speaker 0]: 这整个任务包含了六个对话 section，
[Speaker 0]: 按照这个模型两百 k 的窗口大小，
[Speaker 0]: 我总共用了，
[Speaker 0]: 应该有一百二十万个 token 左右。
[Speaker 0]: 画面上看到的是我用到了最后一个 session，
[Speaker 0]: 这里开头的 prompse 就包含了从最初始的 prompse 到前五个 session 的所有总结。
[Speaker 0]: 他尤其详细记录了上一个 session 里发过的所有事情，
[Speaker 0]: 包括我提交那些信息，
[Speaker 0]: 总结出来那些 bug，
[Speaker 0]: 以及最后是怎么修复的。
[Speaker 0]: 可以看到，
[Speaker 0]: 在第五个 section 里面，
[Speaker 0]: 我基本上都在修一个 bug，
[Speaker 0]: 就是在视频的通话过程中断开重连的问题。
[Speaker 0]: 因为 web RTC 从原理上来说是允许多人视频的。
[Speaker 0]: 所以，
[Speaker 0]: 如果要做到严格的一对一，
[Speaker 0]: 我就需要在业务逻辑里面限制同时连接的人数，
[Speaker 0]: 同时需要实时的记录，
[Speaker 0]: 参与者的进入、
[Speaker 0]: 通话开始断开，
[Speaker 0]: 以及通话结束等状态。
[Speaker 0]: 好的好的，
[Speaker 0]: 这些状态信息除了在 web socket 里面有储存，
[Speaker 0]: 在服务器端的内存里面有储存。
[Speaker 0]: 我还在 REDS 里面也缓存了类似的数据。
[Speaker 0]: 那么在状态变更的时候，
[Speaker 0]: 如果没有处理好这些东西的更新，
[Speaker 0]: 就容易出现内存和缓存的不同步，
[Speaker 0]: 有时候会出现一人断线，
[Speaker 0]: 导致全员下线或者是断线，
[Speaker 0]: 重连之后显示已经满员的错误。
[Speaker 0]: 这还是印证了那句老话，
[Speaker 0]: 一切计算机问题都是状态机问题。
[Speaker 0]: 所以在第五个 session 的那一整个小时里，
[Speaker 0]: 根据我这个 QA 的反馈，
[Speaker 0]:  AI 就在那里反复的翻看自己写代码，
[Speaker 0]: 反复的打补丁，
[Speaker 0]: 包括新增的中间状态、
[Speaker 0]: 修正的内存和缓存的读写顺序，
[Speaker 0]: 以及及时清理过期的 REDS 数据等等。
[Speaker 0]: 虽然最后花了大概二十万个 token 再修好这么一个 bug，
[Speaker 0]: 但综合考虑肯定是比我自己去 debug 更划算的。
[Speaker 0]: 我觉得这也体现出了一个大的趋势，
[Speaker 0]: 就是在那些一句话生成一个没卵用的简单网站的这种 web coding 的时代。
[Speaker 0]: 过去之后，
[Speaker 0]:  AI 编程如果要真正的进入到复杂的软件工程领域，
[Speaker 0]: 它最重要的就是在超长的任务窗口里面持续进行 DBOG 的能力。
[Speaker 0]: 因为稍微有点复杂度的软件，
[Speaker 0]: 都会结合前端后端和数据端，
[Speaker 0]: 加上很多复杂的业务逻辑需求，
[Speaker 0]:  AI 是必然没有办法一次性完成任务的。
[Speaker 0]: 这些我们都心知肚明，
[Speaker 0]: 所以我们注定要把大部分的时间花在测试和 debug 的循环里。
[Speaker 0]: 就拿我这个项目来说，
[Speaker 0]: 初始的 prorop 和初始生成的代码，
[Speaker 0]: 总共只用了十万个 token 左右，
[Speaker 0]: 后面的上百次对话，
[Speaker 0]: 上百万个 token 的消耗，
[Speaker 0]: 基本我这个的 debug。
[Speaker 0]: 而接下来我还有不少想要加上的功能。
[Speaker 0]: 这里单单是通过浏览器原生 API 就可以实现的就有好几个。
[Speaker 0]: 比如说通过 RTC 对它 a channel 进行端对端的文件传输，
[Speaker 0]: 通过 media device、
[Speaker 0]:  API 进行屏幕共享，
[Speaker 0]: 通过 media stream API 进行视频录制，
[Speaker 0]: 通过 web audio、
[Speaker 0]:  API 进行声音降噪，
[Speaker 0]: 以及通过 web code API 对画面打水印等等。
[Speaker 0]: 不得不说，
[Speaker 0]: 浏览器就是一个无穷无尽的宝库。