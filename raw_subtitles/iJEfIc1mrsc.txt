[Speaker 1]: 最近为大家做了多期 open cloud 关的视频，
[Speaker 1]: 而且昨天我还发发了一期 open cld d 级级用它的视频。
[Speaker 1]: 但最近我发现几乎每期视频的评论区都会有留言。
[Speaker 1]: 提到 open cloud 调用 cloud code 会非常消耗 token。
[Speaker 1]: 因为在之前的视频中，
[Speaker 1]: 我有为大家演示过用 open cld 来调用 cloud code 进行编程开发。
[Speaker 1]: 我们只需要为 open cloud 下达一个指令，
[Speaker 1]: 然后让 open cloud 全程操作 cloud code 为我们实现编程开发。
[Speaker 1]: 但是我们如果采使用传统的方式，
[Speaker 1]: 也就是常规的方式，
[Speaker 1]: 让 open 直接调用 cloucloud code 的话，
[Speaker 1]: 那么 open 每隔几秒就会轮询一次，
[Speaker 1]: 检查一下 cloucloud code 的状态，
[Speaker 1]: 以及 cloud code 的输出。
[Speaker 1]: 使用这种传统方式的话，
[Speaker 1]:  open 必须时刻盯着 cloucloud code，
[Speaker 1]: 所以 open cloud 就会消耗非常多的 token。
[Speaker 1]: 所以我发现在评论区大家抱怨 open cloud 调用 cloud code 会消耗更多的 token。
[Speaker 1]: 因为大家采用的是这种常规的传统方式，
[Speaker 1]: 所以 open 要采用不断轮询的方式来查询 cloucloud code 的状态，
[Speaker 1]: 也就是 cloud code，
[Speaker 1]: 它执行的任务越久。
[Speaker 1]: 在 open cloud 中，
[Speaker 1]: 它轮询的次数就越多所，
[Speaker 1]: 消耗的 token 也越多。
[Speaker 1]: 所以我们可以完全不需要用这种传统的方式，
[Speaker 1]: 直接让 open cloud 来调用 cloud code。
[Speaker 1]: 因为无论是 open clde 还是 cloud code，
[Speaker 1]: 它们都非常非常的灵活。
[Speaker 1]: 所以越灵活就越强大，
[Speaker 1]: 就越有利于我们去自定义一些功能，
[Speaker 1]: 从而清松解决。
[Speaker 1]: 用 open cloud 调用 cloud code 的时候，
[Speaker 1]: 产生大量的 token 消耗，
[Speaker 1]: 尤其是 cloud code，
[Speaker 1]: 在前几天新增了 agent teams 这个新特性，
[Speaker 1]: 因为的相当于在 agenteamcloud code 中，
[Speaker 1]: 随时可以创建一个完整的开发团队。
[Speaker 1]: 而且每个 agent 都是独立的进程，
[Speaker 1]: 所以是真正的并行执行。
[Speaker 1]: 而且每个 agent 之间还可以相互通信，
[Speaker 1]: 还随时共享任列列表，
[Speaker 1]: 能自动领领，
[Speaker 1]: 还能实现专职角色工。
[Speaker 1]: 比如说负责开发前端 agenent，
[Speaker 1]: 负责开发后端的呢还有负责测试的 agenagena。
[Speaker 1]: 所以在 cloud code 中有了的 agenteams，
[Speaker 1]: 这个最强大的新特性，
[Speaker 1]: 在 open cloud 中就可以更加轻松的像 cloud code 委派任务，
[Speaker 1]: 让 cloud code 全自动完成整个开发工作流，
[Speaker 1]: 想让 open cloud 更节省 token 的方式来调用 cloud code。
[Speaker 1]: 其实非常简单，
[Speaker 1]: 我们只需要用到 cloud code 的 hooks 功能。
[Speaker 1]: 在 open cloud 中可以结合 cloud code 的 hooks 功能，
[Speaker 1]: 只需要调用 oud code 进行自主开发，
[Speaker 1]: 并且能够实现真正的零轮询，
[Speaker 1]: 而且还能非常节省 token。
[Speaker 1]: 当开发任务完成之后，
[Speaker 1]: 我们还能在聊天软件的群组中自动接收到任务完成的通知，
[Speaker 1]: 包括实现的是什么任务，
[Speaker 1]: 然后项目存储的路径还有耗时，
[Speaker 1]: 还有 cloud code 的的 agenteams 是否已经启用，
[Speaker 1]: 还有具体完成的功能，
[Speaker 1]: 还有项目的文件结构等内容。
[Speaker 1]: 下面我们就看一下我是如何通过 cloud code 的 hooks 来实现了整个流程。
[Speaker 1]: 下面我们先通过这个流程图，
[Speaker 1]: 让大家更直观的感受一下，
[Speaker 1]: 在 cloud code 中，
[Speaker 1]: 通过 hooks 回调来实现了整个步骤是怎样的。
[Speaker 1]: 首先是由 open cloud 将我们要开发的任务委派给 cloud code，
[Speaker 1]: 像这个委派只执行一次，
[Speaker 1]: 而且它是后台运行不会阻塞。
[Speaker 1]:  open cloud 的对话窗口和它的主 agent。
[Speaker 1]: 当 cloud code 接到任务之后，
[Speaker 1]: 它就会进行自主开发，
[Speaker 1]: 还有测试。
[Speaker 1]: 当任务完成之后，
[Speaker 1]: 它就会触发事件。
[Speaker 1]: 第三步就是 cloud code 中 hooks 自动触发，
[Speaker 1]: 它会先将执行结果写入到这个文件中，
[Speaker 1]: 然后再发送 weak event 来唤醒 open cloud，
[Speaker 1]: 在这里采用了 stop event 以及 session int event，
[Speaker 1]: 实现双重保障来保障。
[Speaker 1]: 在聊天软件中，
[Speaker 1]: 我们能够真正收到它的任务完成的通知，
[Speaker 1]: 然后 open cloud 会读取这个文件中的这些结果和状态。
[Speaker 1]: 当他读取完这些结果和状态之后，
[Speaker 1]: 他就会回复给我们，
[Speaker 1]: 也就是通过我们的聊天软件来回复给我们这一状态。
[Speaker 1]: 像这个流程程的话，
[Speaker 1]:  open cloud 只在给 cloud code 派发任务的时候，
[Speaker 1]: 调用一次 cloud code。
[Speaker 1]: 然后这中间的流程不需要 open，
[Speaker 1]:  cloud 参与，
[Speaker 1]: 在最后这里 open cloud 再读取一下这个执行的结果，
[Speaker 1]: 并且将 open 结果发送给用户。
[Speaker 1]: 所以在第一步 open 只是给 cloucloud code 下发一个任务，
[Speaker 1]: 它下发任务的过程，
[Speaker 1]: 所消消耗 totoken 几乎可以忽略不计。
[Speaker 1]: 在最后这里它只是读取一下结果，
[Speaker 1]: 将处理结果发送给用户，
[Speaker 1]: 而且这个结果里的内容非常少，
[Speaker 1]: 甚至不超过一千字。
[Speaker 1]: 所以在最后一个步骤，
[Speaker 1]: 它所消耗的 token 也几乎可以忽略不计。
[Speaker 1]: 在 cloud code 自主完成这个任务的过程中，
[Speaker 1]:  open cloud 不需要对 cloud code 进行轮询。
[Speaker 1]: 好，
[Speaker 1]: 下面为大家讲解一下我是如何实现的。
[Speaker 1]: 在 cloud code 中，
[Speaker 1]: 通过 stop hook 来达到任务完成自动回调的效果。
[Speaker 1]: 在刚才也提到了，
[Speaker 1]: 我们使用了 stop hook，
[Speaker 1]: 还用到了 cloud code session end。
[Speaker 1]: 下面我们简单看一下为什么要用到这两个 hooks。
[Speaker 1]: 在 cloud code 中，
[Speaker 1]: 一共有十四个 hooks，
[Speaker 1]: 之所以我们选择这两个，
[Speaker 1]: 是因为我们构建的这个工作流。
[Speaker 1]: 在 cloud code 中，
[Speaker 1]: 它完成开发之后才会触发这个 hooks。
[Speaker 1]: 所以使用 stop hook 作为主回调，
[Speaker 1]: 在可以保证 cloud code 真正完成开发时才会触发。
[Speaker 1]: 在这里我们还用到了 session end 作为兜底灰调，
[Speaker 1]: 也就是假设 stop hook，
[Speaker 1]: 它没有触发成功，
[Speaker 1]: 还有这个 session and 它能够作为兜底像这样的话，
[Speaker 1]: 我们就能够真正保证 open cloud 向 cloud code 发送一条开发任务，
[Speaker 1]: 然后 cloud code 独立运行。
[Speaker 1]: 在 cloud code 独立运行的这个过程中，
[Speaker 1]: 它并不会消耗 open cloud 上下文，
[Speaker 1]: 当 cloud code 完成开发后才会触发 hooks。
[Speaker 1]: 然后我们的聊天软件就会收到通知，
[Speaker 1]: 下面我们就可以看一下具体的代码。
[Speaker 1]: 在这个代码中，
[Speaker 1]: 我们先看一下这一个脚本，
[Speaker 1]: 它的作用就是将要开发的任务来写入到这一个文件中，
[Speaker 1]: 然后再通过这个脚本来启动 cloud code。
[Speaker 1]: 当 cloud code 完成开发后，
[Speaker 1]: 这个 stop hook 就会自动触发，
[Speaker 1]: 然后就会调用这一个脚本。
[Speaker 1]: 我们可以点开看一下这一个脚本，
[Speaker 1]: 就会将任务发送给 open cloud。
[Speaker 1]: 所以这个自动回调流程它会读取这两个文件里的内容，
[Speaker 1]: 并且写入到这一个文件。
[Speaker 1]: 然后 open 就会将这些信息推送到我们的聊天软件。
[Speaker 1]: 这样的话，
[Speaker 1]: 我们就能够实现在 clouopen cloud 中，
[Speaker 1]: 像 cloud code 下达达开发任务，
[Speaker 1]: 然后由 cloud de de 自主成开开当完成开发之后再触发这两个个 hooks。
[Speaker 1]: 最后我们的聊天软件就会收到推送通知。
[Speaker 1]: 好，
[Speaker 1]: 下面我们可以先用一个简单的开发案例来测试一下。
[Speaker 1]: 在主 agent 和这里，
[Speaker 1]: 我们直接在对话框中输入我们的任务。
[Speaker 1]: 我输入的是用 cloud code 的 agent team 协协模式，
[Speaker 1]: 构建一个基于物理引擎，
[Speaker 1]: 还有 HTMLCSS 的带材质系统的落沙模拟游戏。
[Speaker 1]: 然后我们直接发送看一下这个效果。
[Speaker 0]: 嗯，
[Speaker 1]: 这里很快输出提示，
[Speaker 1]: 他已经将这个任务派发给 cloud code 的 agent teams。
[Speaker 1]: 这个开发模式就是调用 cloud code 的 agent teams，
[Speaker 1]: 多智能体协作，
[Speaker 1]: 这里还给出了这个工作路径，
[Speaker 1]: 然后这里他提到完成后会自动通知到群里。
[Speaker 1]: 像这样的话，
[Speaker 1]: 这个主 agent 的的线程并没有被阻塞，
[Speaker 1]: 他还可以继续为我们执行其他的任务。
[Speaker 1]: 比如说我们在这个主 agent 中继继输入任务，
[Speaker 1]: 比如说让他查询新加坡今天的天气，
[Speaker 1]: 然后我们直接点击发送，
[Speaker 1]: 看一下最终的效果。
[Speaker 1]: 像我们如果采取传统的方式，
[Speaker 1]: 在 open cloud 中来调用 cloud code，
[Speaker 1]: 在主 agent 中必须等到 cloud code 真正完成开发之后，
[Speaker 1]: 这个主 agent 呢才会继续执行我们的其他任务。
[Speaker 1]: 像我们采取了现在这种方式，
[Speaker 1]: 这个主 agent 的进程并没有被阻塞。
[Speaker 1]: 然后我们让他查询新加坡的天气，
[Speaker 1]: 然后这里他就很快查询了一个天气，
[Speaker 1]: 然后我们还可以继续输入其他任务。
[Speaker 1]: 比如说讲个笑话，
[Speaker 1]: 然后这里他就很快输出了一一个笑话。
[Speaker 1]: 而 cloud code 在后台完全是自主运行，
[Speaker 1]: 不需要我们去干预。
[Speaker 1]: 然后我们只需要等待 cloud code 完成之后，
[Speaker 1]: 将完成后的消息推送到这一个群组里就可以了。
[Speaker 1]: 之所以设置为将完成后的消息单独推送到一个群组，
[Speaker 1]: 是因为我们在这个主的中可能还在进行其他任务的操作。
[Speaker 1]: 比如说让他讲的笑话，
[Speaker 1]: 他在讲笑话的时候，
[Speaker 1]: 突然多出来一条任务完成混乱，
[Speaker 1]: 这样会导致这个上下文窗口比较混乱。
[Speaker 1]: 所以我们就将它完成后的这个消息及推送，
[Speaker 1]: 单独推送到一个群组里。
[Speaker 1]: 这样的话就不会占用这个主 agent 的这个聊天窗口。
[Speaker 1]: 在这个群组里，
[Speaker 1]: 我们就看到了这个消息推送，
[Speaker 1]: 我们点开群组查看一下。
[Speaker 1]: 在这里我们就看到了这个任务，
[Speaker 1]: 推送这里提示 cloud code 任务完成，
[Speaker 1]: 这里是开发的这个游戏，
[Speaker 1]: 然后这里是游戏的路径，
[Speaker 1]: 在 cloud code 中使用的就是 a 的 enteams，
[Speaker 1]: 这里就是给出的项目文件。
[Speaker 1]: 然后这里他还推送了第二条消息，
[Speaker 1]: 这里还给出了完成时间大概六分钟。
[Speaker 1]: 然后这里还包含一百八十四个测试是通过，
[Speaker 1]: 然后这里就是给出的交付。
[Speaker 1]: 然后这里还给出了这些性能，
[Speaker 1]: 下面我们可以输入提示词，
[Speaker 1]: 让他将代码文件打包发给我。
[Speaker 1]: 这样的话，
[Speaker 1]: 我们就可以在本地打开进行测试。
[Speaker 1]: 因为我的 open cloud 是运行在云端的。
[Speaker 1]: 好，
[Speaker 1]: 这里它将为我们开发的这个项目文件发送给了我们这里还提示解压后，
[Speaker 1]: 在浏览器中就可以打开使用。
[Speaker 1]: 然后我们直接点开，
[Speaker 1]: 然后我们在浏览器中打开看一下这个效果，
[Speaker 1]: 就是它开发的这个落沙游戏。
[Speaker 1]: 我们可以先测试一下，
[Speaker 1]: 我们选择这个沙子。
[Speaker 1]: 好，
[Speaker 1]: 这样点击之后，
[Speaker 1]: 这个沙子就落在了底下，
[Speaker 1]: 然后我们再点击这个水。
[Speaker 1]: 好，
[Speaker 1]: 可以看到水落在了沙子上，
[Speaker 1]: 然后我们再给它加一把火。
[Speaker 1]: 可以看到这个火会往天上飘，
[Speaker 1]: 再给它加一些木头，
[Speaker 1]: 然后再给它加一些蒸汽。
[Speaker 1]: 可以看到这个蒸汽飘到木头上会变成雨像，
[Speaker 1]: 这样的话我们就真正实现了。
[Speaker 1]: 在 open cloud 中，
[Speaker 1]: 调用 cloud code 进行开发，
[Speaker 1]: 大家就不用担心。
[Speaker 1]: 在 open cloud 中，
[Speaker 1]: 调用 cloud code，
[Speaker 1]: 非常浪费 token，
[Speaker 1]:  open 所消耗的 cloutoken 几乎可以忽略不计。
[Speaker 1]: 哪怕我们不在电脑前，
[Speaker 1]: 也可以通过手机向 open 下达开发指令。
[Speaker 1]: 当完成开发之后，
[Speaker 1]: 我们就可以在群组中查看推送的这些消息。
[Speaker 1]: 本期视频所用到的代码和笔记，
[Speaker 1]: 我都会放在视频下方的描述栏或者评论区。
[Speaker 1]: 如果你在视频下方无法找到的话，
[Speaker 1]: 也可以通过我的博客去查找本期视频，
[Speaker 1]: 所有对应的笔记。
[Speaker 1]: 好，
[Speaker 1]: 本期视频就做到这里，
[Speaker 1]: 欢迎大家点赞、
[Speaker 1]: 关注和转发，
[Speaker 1]: 谢谢大家观看。